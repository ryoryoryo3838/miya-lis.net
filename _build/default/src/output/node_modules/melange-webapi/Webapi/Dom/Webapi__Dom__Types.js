// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Stdlib from "melange/stdlib.js";

function encodeCompareHow(param) {
  switch (param) {
    case /* StartToStart */ 0 :
      return 0;
    case /* StartToEnd */ 1 :
      return 1;
    case /* EndToEnd */ 2 :
      return 2;
    case /* EndToStart */ 3 :
      return 3;
  }
}

function decodeCompareResult(param) {
  if ((param + 1 >>> 0) > 2) {
    return /* Unknown */ 3;
  } else {
    return param + 1 | 0;
  }
}

function decodeCompatMode(param) {
  switch (param) {
    case "BackCompat" :
      return /* BackCompat */ 0;
    case "CSS1Compat" :
      return /* CSS1Compat */ 1;
    default:
      return /* Unknown */ 2;
  }
}

function encodeContentEditable(param) {
  switch (param) {
    case /* True */ 0 :
      return "true";
    case /* False */ 1 :
      return "false";
    case /* Inherit */ 2 :
      return "inherit";
    case /* Unknown */ 3 :
      return "";
  }
}

function decodeContentEditable(param) {
  switch (param) {
    case "false" :
      return /* False */ 1;
    case "inherit" :
      return /* Inherit */ 2;
    case "true" :
      return /* True */ 0;
    default:
      return /* Unknown */ 3;
  }
}

function decodeDeltaMode(param) {
  if (param > 2 || param < 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
        MEL_EXN_ID: Stdlib.Invalid_argument,
        _1: "invalid deltaMode"
      });
  }
  return param;
}

function encodeDesignMode(param) {
  switch (param) {
    case /* On */ 0 :
      return "on";
    case /* Off */ 1 :
      return "off";
    case /* Unknown */ 2 :
      return "";
  }
}

function decodeDesignMode(param) {
  switch (param) {
    case "off" :
      return /* Off */ 1;
    case "on" :
      return /* On */ 0;
    default:
      return /* Unknown */ 2;
  }
}

function encodeDir(param) {
  switch (param) {
    case /* Ltr */ 0 :
      return "ltr";
    case /* Rtl */ 1 :
      return "rtl";
    case /* Unknown */ 2 :
      return "";
  }
}

function decodeDir(param) {
  switch (param) {
    case "ltr" :
      return /* Ltr */ 0;
    case "rtl" :
      return /* Rtl */ 1;
    default:
      return /* Unknown */ 2;
  }
}

function decode(param) {
  if (param > 3 || param < 0) {
    return /* Unknown */ 4;
  } else {
    return param;
  }
}

const EventPhase = {
  decode: decode
};

function encodeFilterAction(param) {
  switch (param) {
    case /* Accept */ 0 :
      return 1;
    case /* Reject */ 1 :
      return 2;
    case /* Skip */ 2 :
      return 3;
  }
}

function encodeInsertPosition(param) {
  switch (param) {
    case /* BeforeBegin */ 0 :
      return "beforebegin";
    case /* AfterBegin */ 1 :
      return "afterbegin";
    case /* BeforeEnd */ 2 :
      return "beforeend";
    case /* AfterEnd */ 3 :
      return "afterend";
  }
}

function encodeModifierKey(param) {
  switch (param) {
    case /* Alt */ 0 :
      return "Alt";
    case /* AltGraph */ 1 :
      return "AltGraph";
    case /* CapsLock */ 2 :
      return "CapsLock";
    case /* Control */ 3 :
      return "Control";
    case /* Fn */ 4 :
      return "Fn";
    case /* FnLock */ 5 :
      return "FnLock";
    case /* Hyper */ 6 :
      return "Hyper";
    case /* Meta */ 7 :
      return "Meta";
    case /* NumLock */ 8 :
      return "NumLock";
    case /* ScrollLock */ 9 :
      return "ScrollLock";
    case /* Shift */ 10 :
      return "Shift";
    case /* Super */ 11 :
      return "Super";
    case /* Symbol */ 12 :
      return "Symbol";
    case /* SymbolLock */ 13 :
      return "SymbolLock";
  }
}

function decodeNodeType(param) {
  if (param > 12 || param < 1) {
    return /* Unknown */ 12;
  } else {
    return param - 1 | 0;
  }
}

function decodePointerType(param) {
  switch (param) {
    case "mouse" :
      return /* Mouse */ 0;
    case "pen" :
      return /* Pen */ 1;
    case "touch|" :
      return /* Touch */ 2;
    default:
      return /* Unknown */ 3;
  }
}

function decodeReadyState(param) {
  switch (param) {
    case "complete" :
      return /* Complete */ 2;
    case "interactive" :
      return /* Interactive */ 1;
    case "loading" :
      return /* Loading */ 0;
    default:
      return /* Unknown */ 3;
  }
}

function decodeShadowRootMode(param) {
  switch (param) {
    case "closed" :
      return /* Closed */ 1;
    case "open" :
      return /* Open */ 0;
    default:
      throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
          MEL_EXN_ID: Stdlib.Invalid_argument,
          _1: "Unknown shadowRootMode"
        });
  }
}

function decodeVisibilityState(param) {
  switch (param) {
    case "hidden" :
      return /* Hidden */ 1;
    case "prerender" :
      return /* Prerender */ 2;
    case "unloaded" :
      return /* Unloaded */ 3;
    case "visible" :
      return /* Visible */ 0;
    default:
      return /* Unknown */ 4;
  }
}

function many(param) {
  if (param) {
    return param.hd | many(param.tl);
  } else {
    return 0;
  }
}

const WhatToShow = {
  _All: -1,
  _Element: 1,
  _Attribute: 2,
  _Text: 4,
  _CDATASection: 8,
  _EntityReference: 16,
  _Entity: 32,
  _ProcessingInstruction: 64,
  _Comment: 128,
  _Document: 256,
  _DocumentType: 512,
  _DocumentFragment: 1024,
  _Notation: 2048,
  many: many
};

export {
  encodeCompareHow,
  decodeCompareResult,
  decodeCompatMode,
  encodeContentEditable,
  decodeContentEditable,
  decodeDeltaMode,
  encodeDesignMode,
  decodeDesignMode,
  encodeDir,
  decodeDir,
  EventPhase,
  encodeFilterAction,
  encodeInsertPosition,
  encodeModifierKey,
  decodeNodeType,
  decodePointerType,
  decodeReadyState,
  decodeShadowRootMode,
  decodeVisibilityState,
  WhatToShow,
}
/* No side effect */
