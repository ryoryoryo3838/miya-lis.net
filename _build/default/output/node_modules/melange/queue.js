// Generated by Melange

import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Seq from "./seq.js";

const Empty = /* @__PURE__ */ Caml_exceptions.create("Stdlib.Queue.Empty");

function create(param) {
  return {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
}

function clear(q) {
  q.length = 0;
  q.first = /* Nil */ 0;
  q.last = /* Nil */ 0;
}

function add(x, q) {
  const cell = {
    TAG: /* Cons */ 0,
    content: x,
    next: /* Nil */ 0
  };
  const last = q.last;
  if (/* tag */ typeof last === "number" || typeof last === "string") {
    q.length = 1;
    q.first = cell;
    q.last = cell;
    return;
  }
  q.length = q.length + 1 | 0;
  last.next = cell;
  q.last = cell;
}

function peek(q) {
  const match = q.first;
  if (!/* tag */ (typeof match === "number" || typeof match === "string")) {
    return match.content;
  }
  throw new Caml_js_exceptions.MelangeError(Empty, {
      MEL_EXN_ID: Empty
    });
}

function peek_opt(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  } else {
    return Caml_option.some(match.content);
  }
}

function take(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
  }
  const content = match.content;
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    clear(q);
    return content;
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
  return content;
}

function take_opt(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    return;
  }
  const content = match.content;
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    clear(q);
    return Caml_option.some(content);
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
  return Caml_option.some(content);
}

function drop(q) {
  const match = q.first;
  if (/* tag */ typeof match === "number" || typeof match === "string") {
    throw new Caml_js_exceptions.MelangeError(Empty, {
        MEL_EXN_ID: Empty
      });
  }
  const match$1 = match.next;
  if (/* tag */ typeof match$1 === "number" || typeof match$1 === "string") {
    return clear(q);
  }
  const next = match.next;
  q.length = q.length - 1 | 0;
  q.first = next;
}

function copy(q) {
  let q_res = {
    length: q.length,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  let _prev = /* Nil */ 0;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const prev = _prev;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      q_res.last = prev;
      return q_res;
    }
    const next = cell.next;
    const res = {
      TAG: /* Cons */ 0,
      content: cell.content,
      next: /* Nil */ 0
    };
    if (/* tag */ typeof prev === "number" || typeof prev === "string") {
      q_res.first = res;
    } else {
      prev.next = res;
    }
    _cell = next;
    _prev = res;
    continue;
  };
}

function is_empty(q) {
  return q.length === 0;
}

function length(q) {
  return q.length;
}

function iter(f, q) {
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      return;
    }
    const next = cell.next;
    Curry._1(f, cell.content);
    _cell = next;
    continue;
  };
}

function fold(f, accu, q) {
  let _accu = accu;
  let _cell = q.first;
  while (true) {
    const cell = _cell;
    const accu$1 = _accu;
    if (/* tag */ typeof cell === "number" || typeof cell === "string") {
      return accu$1;
    }
    const next = cell.next;
    const accu$2 = Curry._2(f, accu$1, cell.content);
    _cell = next;
    _accu = accu$2;
    continue;
  };
}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return;
  }
  const last = q2.last;
  if (/* tag */ typeof last === "number" || typeof last === "string") {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear(q1);
  }
  q2.length = q2.length + q1.length | 0;
  last.next = q1.first;
  q2.last = q1.last;
  clear(q1);
}

function to_seq(q) {
  const aux = function (c, param) {
    if (/* tag */ typeof c === "number" || typeof c === "string") {
      return /* Nil */ 0;
    }
    const next = c.next;
    return {
      TAG: /* Cons */ 0,
      _0: c.content,
      _1: (function (param) {
        return aux(next, param);
      })
    };
  };
  const partial_arg = q.first;
  return function (param) {
    return aux(partial_arg, param);
  };
}

function add_seq(q, i) {
  Stdlib__Seq.iter((function (x) {
    add(x, q);
  }), i);
}

function of_seq(g) {
  const q = {
    length: 0,
    first: /* Nil */ 0,
    last: /* Nil */ 0
  };
  add_seq(q, g);
  return q;
}

const push = add;

const pop = take;

const top = peek;

export {
  Empty,
  create,
  add,
  push,
  take,
  take_opt,
  pop,
  peek,
  peek_opt,
  top,
  drop,
  clear,
  copy,
  is_empty,
  length,
  iter,
  fold,
  transfer,
  to_seq,
  add_seq,
  of_seq,
}
/* No side effect */
