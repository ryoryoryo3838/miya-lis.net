import {
  caml_equal
} from "./chunk-Y6CS5PWF.js";
import {
  concat as concat2,
  fold_left
} from "./chunk-GSNAPODV.js";
import "./chunk-U34IA575.js";
import {
  some
} from "./chunk-IW5MXQOG.js";
import {
  MelangeError,
  _1,
  _2,
  blit,
  concat,
  create,
  get,
  internalToOCamlException,
  make,
  set,
  sub
} from "./chunk-3PFLCYLG.js";
import "./chunk-5WRI5ZAA.js";

// _build/default/src/output/node_modules/melange/array.js
var Floatarray = {};
function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.init"
    });
  }
  const res = make(l, _1(f, 0));
  for (let i = 1; i < l; ++i) {
    res[i] = _1(f, i);
  }
  return res;
}
function make_matrix(sx, sy, init2) {
  if (sy < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.make_matrix"
    });
  }
  const res = make(sx, []);
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      res[x] = make(sy, init2);
    }
  }
  return res;
}
function init_matrix(sx, sy, f) {
  if (sy < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.init_matrix"
    });
  }
  const res = make(sx, []);
  if (sy > 0) {
    for (let x = 0; x < sx; ++x) {
      const row = make(sy, _2(f, x, 0));
      for (let y = 1; y < sy; ++y) {
        row[y] = _2(f, x, y);
      }
      res[x] = row;
    }
  }
  return res;
}
function copy(a) {
  const l = a.length;
  if (l === 0) {
    return [];
  } else {
    return sub(a, 0, l);
  }
}
function append(a1, a2) {
  const l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}
function sub2(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.sub"
    });
  }
  return sub(a, ofs, len);
}
function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.fill"
    });
  }
  for (let i = ofs, i_finish = ofs + len | 0; i < i_finish; ++i) {
    a[i] = v;
  }
}
function blit2(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.blit"
    });
  }
  blit(a1, ofs1, a2, ofs2, len);
}
function iter(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    _1(f, a[i]);
  }
}
function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.iter2: arrays must have the same length"
    });
  }
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    _2(f, a[i], b[i]);
  }
}
function map(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = make(l, _1(f, a[0]));
  for (let i = 1; i < l; ++i) {
    r[i] = _1(f, a[i]);
  }
  return r;
}
function map_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = _1(f, a[i]);
  }
}
function mapi_inplace(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    a[i] = _2(f, i, a[i]);
  }
}
function map2(f, a, b) {
  const la = a.length;
  const lb = b.length;
  if (la !== lb) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.map2: arrays must have the same length"
    });
  }
  if (la === 0) {
    return [];
  }
  const r = make(la, _2(f, a[0], b[0]));
  for (let i = 1; i < la; ++i) {
    r[i] = _2(f, a[i], b[i]);
  }
  return r;
}
function iteri(f, a) {
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    _2(f, i, a[i]);
  }
}
function mapi(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = make(l, _2(f, 0, a[0]));
  for (let i = 1; i < l; ++i) {
    r[i] = _2(f, i, a[i]);
  }
  return r;
}
function to_list(a) {
  let _i = a.length - 1 | 0;
  let _res = (
    /* [] */
    0
  );
  while (true) {
    const res = _res;
    const i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: a[i],
      tl: res
    };
    _i = i - 1 | 0;
    continue;
  }
  ;
}
function list_length(_accu, _param) {
  while (true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue;
  }
  ;
}
function of_list(l) {
  if (!l) {
    return [];
  }
  const a = make(list_length(0, l), l.hd);
  let _i = 1;
  let _param = l.tl;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return a;
    }
    a[i] = param.hd;
    _param = param.tl;
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function fold_left2(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = _2(f, r, a[i]);
  }
  return r;
}
function fold_left_map(f, acc, input_array) {
  const len = input_array.length;
  if (len === 0) {
    return [
      acc,
      []
    ];
  }
  const match = _2(f, acc, input_array[0]);
  const output_array = make(len, match[1]);
  let acc$1 = match[0];
  for (let i = 1; i < len; ++i) {
    const match$1 = _2(f, acc$1, input_array[i]);
    acc$1 = match$1[0];
    output_array[i] = match$1[1];
  }
  return [
    acc$1,
    output_array
  ];
}
function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = _2(f, a[i], r);
  }
  return r;
}
function exists(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (_1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function for_all(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!_1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function for_all2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.for_all2"
    });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return true;
    }
    if (!_2(p, l1[i], l2[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function exists2(p, l1, l2) {
  const n1 = l1.length;
  const n2 = l2.length;
  if (n1 !== n2) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.exists2"
    });
  }
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n1) {
      return false;
    }
    if (_2(p, l1[i], l2[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function mem(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (caml_equal(a[i], x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function memq(x, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function find_opt(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const x = a[i];
    if (_1(p, x)) {
      return some(x);
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function find_index(p, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    if (_1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function find_map(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = _1(f, a[i]);
    if (r !== void 0) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function find_mapi(f, a) {
  const n = a.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return;
    }
    const r = _2(f, i, a[i]);
    if (r !== void 0) {
      return r;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function split(x) {
  if (caml_equal(x, [])) {
    return [
      [],
      []
    ];
  }
  const match = x[0];
  const n = x.length;
  const a = make(n, match[0]);
  const b = make(n, match[1]);
  for (let i = 1; i < n; ++i) {
    const match$1 = x[i];
    a[i] = match$1[0];
    b[i] = match$1[1];
  }
  return [
    a,
    b
  ];
}
function combine(a, b) {
  const na = a.length;
  const nb = b.length;
  if (na !== nb) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Array.combine"
    });
  }
  if (na === 0) {
    return [];
  }
  const x = make(na, [
    a[0],
    b[0]
  ]);
  for (let i = 1; i < na; ++i) {
    x[i] = [
      a[i],
      b[i]
    ];
  }
  return x;
}
var Bottom = create("Stdlib.Array.Bottom");
function sort(cmp, a) {
  const maxson = function(l2, i) {
    const i31 = ((i + i | 0) + i | 0) + 1 | 0;
    let x = i31;
    if ((i31 + 2 | 0) < l2) {
      if (_2(cmp, get(a, i31), get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (_2(cmp, get(a, x), get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l2 && _2(cmp, get(a, i31), get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l2) {
      return i31;
    }
    throw new MelangeError(Bottom, {
      MEL_EXN_ID: Bottom,
      _1: i
    });
  };
  const trickle = function(l2, i, e) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l2, i$1);
        if (_2(cmp, get(a, j), e) <= 0) {
          return set(a, i$1, e);
        }
        set(a, i$1, get(a, j));
        _i = j;
        continue;
      }
      ;
    } catch (raw_exn) {
      const exn = internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return set(a, exn._1, e);
      }
      throw exn;
    }
  };
  const bubble = function(l2, i) {
    try {
      let _i = i;
      while (true) {
        const i$1 = _i;
        const j = maxson(l2, i$1);
        set(a, i$1, get(a, j));
        _i = j;
        continue;
      }
      ;
    } catch (raw_exn) {
      const exn = internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Bottom) {
        return exn._1;
      }
      throw exn;
    }
  };
  const trickleup = function(_i, e) {
    while (true) {
      const i = _i;
      const father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw new MelangeError("Assert_failure", {
          MEL_EXN_ID: "Assert_failure",
          _1: [
            "array.cppo.ml",
            378,
            4
          ]
        });
      }
      if (_2(cmp, get(a, father), e) >= 0) {
        return set(a, i, e);
      }
      set(a, i, get(a, father));
      if (father <= 0) {
        return set(a, 0, e);
      }
      _i = father;
      continue;
    }
    ;
  };
  const l = a.length;
  for (let i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i) {
    trickle(l, i, get(a, i));
  }
  for (let i$1 = l - 1 | 0; i$1 >= 2; --i$1) {
    const e = get(a, i$1);
    set(a, i$1, get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return;
  }
  const e$1 = get(a, 1);
  set(a, 1, get(a, 0));
  set(a, 0, e$1);
}
function stable_sort(cmp, a) {
  const merge = function(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    const src1r = src1ofs + src1len | 0;
    const src2r = src2ofs + src2len | 0;
    let _i1 = src1ofs;
    let _s1 = get(a, src1ofs);
    let _i2 = src2ofs;
    let _s2 = get(src2, src2ofs);
    let _d = dstofs;
    while (true) {
      const d = _d;
      const s2 = _s2;
      const i2 = _i2;
      const s1 = _s1;
      const i1 = _i1;
      if (_2(cmp, s1, s2) <= 0) {
        set(dst, d, s1);
        const i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit2(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = get(a, i1$1);
        _i1 = i1$1;
        continue;
      }
      set(dst, d, s2);
      const i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit2(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = get(src2, i2$1);
      _i2 = i2$1;
      continue;
    }
    ;
  };
  const isortto = function(srcofs, dst, dstofs, len) {
    for (let i = 0; i < len; ++i) {
      const e = get(a, srcofs + i | 0);
      let j = (dstofs + i | 0) - 1 | 0;
      while (j >= dstofs && _2(cmp, get(dst, j), e) > 0) {
        set(dst, j + 1 | 0, get(dst, j));
        j = j - 1 | 0;
      }
      ;
      set(dst, j + 1 | 0, e);
    }
  };
  const sortto = function(srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    const l12 = len / 2 | 0;
    const l22 = len - l12 | 0;
    sortto(srcofs + l12 | 0, dst, dstofs + l12 | 0, l22);
    sortto(srcofs, a, srcofs + l22 | 0, l12);
    merge(srcofs + l22 | 0, l12, dst, dstofs + l12 | 0, l22, dst, dstofs);
  };
  const l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = make(l2, get(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}
function shuffle_contract_violation(i, j) {
  const s = concat2("", {
    hd: "Array.shuffle: 'rand ",
    tl: {
      hd: String(i + 1 | 0),
      tl: {
        hd: "' returned ",
        tl: {
          hd: String(j),
          tl: {
            hd: ", out of expected range [0; ",
            tl: {
              hd: String(i),
              tl: {
                hd: "]",
                tl: (
                  /* [] */
                  0
                )
              }
            }
          }
        }
      }
    }
  });
  throw new MelangeError("Invalid_argument", {
    MEL_EXN_ID: "Invalid_argument",
    _1: s
  });
}
function shuffle(rand, a) {
  for (let i = a.length - 1 | 0; i >= 1; --i) {
    const j = _1(rand, i + 1 | 0);
    if (!(0 <= j && j <= i)) {
      shuffle_contract_violation(i, j);
    }
    const v = a[i];
    a[i] = a[j];
    a[j] = v;
  }
}
function to_seq(a) {
  const aux = function(i, param) {
    if (i >= a.length) {
      return (
        /* Nil */
        0
      );
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: (
        /* Cons */
        0
      ),
      _0: x,
      _1: function(param2) {
        return aux(partial_arg, param2);
      }
    };
  };
  return function(param) {
    return aux(0, param);
  };
}
function to_seqi(a) {
  const aux = function(i, param) {
    if (i >= a.length) {
      return (
        /* Nil */
        0
      );
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return {
      TAG: (
        /* Cons */
        0
      ),
      _0: [
        i,
        x
      ],
      _1: function(param2) {
        return aux(partial_arg, param2);
      }
    };
  };
  return function(param) {
    return aux(0, param);
  };
}
function of_seq(i) {
  let l = fold_left(
    function(acc, x) {
      return {
        hd: x,
        tl: acc
      };
    },
    /* [] */
    0,
    i
  );
  if (!l) {
    return [];
  }
  const len = list_length(0, l);
  const a = make(len, l.hd);
  let _i = len - 2 | 0;
  let _param = l.tl;
  while (true) {
    const param = _param;
    const i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue;
  }
  ;
}
var concat3 = concat;
var fast_sort = stable_sort;
export {
  Floatarray,
  append,
  blit2 as blit,
  combine,
  concat3 as concat,
  copy,
  exists,
  exists2,
  fast_sort,
  fill,
  find_index,
  find_map,
  find_mapi,
  find_opt,
  fold_left2 as fold_left,
  fold_left_map,
  fold_right,
  for_all,
  for_all2,
  init,
  init_matrix,
  iter,
  iter2,
  iteri,
  make_matrix,
  map,
  map2,
  map_inplace,
  mapi,
  mapi_inplace,
  mem,
  memq,
  of_list,
  of_seq,
  shuffle,
  sort,
  split,
  stable_sort,
  sub2 as sub,
  to_list,
  to_seq,
  to_seqi
};
//# sourceMappingURL=melange_array__js.js.map
