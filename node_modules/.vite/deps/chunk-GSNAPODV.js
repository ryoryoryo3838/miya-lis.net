import {
  Not_found,
  bswap16,
  bswap32,
  bswap64,
  bytes_of_string,
  bytes_to_string,
  caml_blit_bytes,
  caml_blit_string,
  caml_create_bytes,
  caml_fill_bytes,
  caml_string_compare,
  caml_sys_executable_name,
  get,
  get16,
  get16u,
  get2,
  get32,
  get64,
  os_type,
  resolve,
  set
} from "./chunk-U34IA575.js";
import {
  MelangeError,
  _1,
  _2,
  create,
  internalToOCamlException
} from "./chunk-3PFLCYLG.js";

// _build/default/src/output/node_modules/melange/char.js
function lowercase_ascii(c) {
  if (c > 90 || c < 65) {
    return c;
  } else {
    return c + 32 | 0;
  }
}
function uppercase_ascii(c) {
  if (c > 122 || c < 97) {
    return c;
  } else {
    return c - 32 | 0;
  }
}

// _build/default/src/output/node_modules/melange/int.js
function min(x, y) {
  if (x <= y) {
    return x;
  } else {
    return y;
  }
}

// _build/default/src/output/node_modules/melange/camlinternalLazy.js
var Undefined = create("CamlinternalLazy.Undefined");

// _build/default/src/output/node_modules/melange/seq.js
function fold_left(f, _acc, _seq) {
  while (true) {
    const seq = _seq;
    const acc = _acc;
    const match = _1(seq, void 0);
    if (
      /* tag */
      typeof match === "number" || typeof match === "string"
    ) {
      return acc;
    }
    const acc$1 = _2(f, acc, match._0);
    _seq = match._1;
    _acc = acc$1;
    continue;
  }
  ;
}
function iter(f, _seq) {
  while (true) {
    const seq = _seq;
    const match = _1(seq, void 0);
    if (
      /* tag */
      typeof match === "number" || typeof match === "string"
    ) {
      return;
    }
    _1(f, match._0);
    _seq = match._1;
    continue;
  }
  ;
}
var Forced_twice = create("Stdlib.Seq.Forced_twice");

// _build/default/src/output/node_modules/melange/sys.js
var executable_name = caml_sys_executable_name(void 0);
var os_type2 = os_type(void 0);
var big_endian = false;
var unix = os_type(void 0) === "Unix";
var win32 = os_type(void 0) === "Win32";
var Break = create("Stdlib.Sys.Break");
var int_size = 32;
var max_string_length = 2147483647;

// _build/default/src/output/node_modules/melange/bytes.js
function make3(n, c) {
  const s = caml_create_bytes(n);
  caml_fill_bytes(s, 0, n, c);
  return s;
}
function init(n, f) {
  const s = caml_create_bytes(n);
  for (let i = 0; i < n; ++i) {
    s[i] = _1(f, i);
  }
  return s;
}
var empty = [];
function copy(s) {
  const len = s.length;
  const r = caml_create_bytes(len);
  caml_blit_bytes(s, 0, r, 0, len);
  return r;
}
function to_string(b) {
  return bytes_to_string(copy(b));
}
function of_string(s) {
  return copy(bytes_of_string(s));
}
function sub(s, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.sub / Bytes.sub"
    });
  }
  const r = caml_create_bytes(len);
  caml_blit_bytes(s, ofs, r, 0, len);
  return r;
}
function blit(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "Bytes.blit"
    });
  }
  caml_blit_bytes(s1, ofs1, s2, ofs2, len);
}
function blit_string(s1, ofs1, s2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (s1.length - len | 0) || ofs2 < 0 || ofs2 > (s2.length - len | 0)) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.blit / Bytes.blit_string"
    });
  }
  caml_blit_string(s1, ofs1, s2, ofs2, len);
}
function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}
function trim(s) {
  const len = s.length;
  let i = 0;
  while (i < len && is_space(s[i])) {
    i = i + 1 | 0;
  }
  ;
  let j = len - 1 | 0;
  while (j >= i && is_space(s[j])) {
    j = j - 1 | 0;
  }
  ;
  if (j >= i) {
    return sub(s, i, (j - i | 0) + 1 | 0);
  } else {
    return empty;
  }
}
function unsafe_escape(s) {
  let n = 0;
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    const match = s[i];
    n = n + (match >= 32 ? match > 92 || match < 34 ? match >= 127 ? 4 : 1 : match > 91 || match < 35 ? 2 : 1 : match >= 11 ? match !== 13 ? 4 : 2 : match >= 8 ? 2 : 4) | 0;
  }
  if (n === s.length) {
    return s;
  }
  const s$p = caml_create_bytes(n);
  n = 0;
  for (let i$1 = 0, i_finish$1 = s.length; i$1 < i_finish$1; ++i$1) {
    const c = s[i$1];
    let exit = 0;
    if (c >= 35) {
      if (c !== 92) {
        if (c >= 127) {
          exit = 1;
        } else {
          s$p[n] = c;
        }
      } else {
        exit = 2;
      }
    } else if (c >= 32) {
      if (c >= 34) {
        exit = 2;
      } else {
        s$p[n] = c;
      }
    } else if (c >= 14) {
      exit = 1;
    } else {
      switch (c) {
        case 8:
          s$p[n] = /* '\\' */
          92;
          n = n + 1 | 0;
          s$p[n] = /* 'b' */
          98;
          break;
        case 9:
          s$p[n] = /* '\\' */
          92;
          n = n + 1 | 0;
          s$p[n] = /* 't' */
          116;
          break;
        case 10:
          s$p[n] = /* '\\' */
          92;
          n = n + 1 | 0;
          s$p[n] = /* 'n' */
          110;
          break;
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 11:
        case 12:
          exit = 1;
          break;
        case 13:
          s$p[n] = /* '\\' */
          92;
          n = n + 1 | 0;
          s$p[n] = /* 'r' */
          114;
          break;
      }
    }
    switch (exit) {
      case 1:
        s$p[n] = /* '\\' */
        92;
        n = n + 1 | 0;
        s$p[n] = 48 + (c / 100 | 0) | 0;
        n = n + 1 | 0;
        s$p[n] = 48 + (c / 10 | 0) % 10 | 0;
        n = n + 1 | 0;
        s$p[n] = 48 + c % 10 | 0;
        break;
      case 2:
        s$p[n] = /* '\\' */
        92;
        n = n + 1 | 0;
        s$p[n] = c;
        break;
    }
    n = n + 1 | 0;
  }
  return s$p;
}
function map(f, s) {
  const l = s.length;
  if (l === 0) {
    return s;
  }
  const r = caml_create_bytes(l);
  for (let i = 0; i < l; ++i) {
    r[i] = _1(f, s[i]);
  }
  return r;
}
function mapi(f, s) {
  const l = s.length;
  if (l === 0) {
    return s;
  }
  const r = caml_create_bytes(l);
  for (let i = 0; i < l; ++i) {
    r[i] = _2(f, i, s[i]);
  }
  return r;
}
function fold_left2(f, x, a) {
  let r = x;
  for (let i = 0, i_finish = a.length; i < i_finish; ++i) {
    r = _2(f, r, a[i]);
  }
  return r;
}
function fold_right(f, a, x) {
  let r = x;
  for (let i = a.length - 1 | 0; i >= 0; --i) {
    r = _2(f, a[i], r);
  }
  return r;
}
function exists(p, s) {
  const n = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (_1(p, s[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function for_all(p, s) {
  const n = s.length;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!_1(p, s[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function uppercase_ascii2(s) {
  return map(uppercase_ascii, s);
}
function lowercase_ascii2(s) {
  return map(lowercase_ascii, s);
}
function apply1(f, s) {
  if (s.length === 0) {
    return s;
  }
  const r = copy(s);
  r[0] = _1(f, s[0]);
  return r;
}
function capitalize_ascii(s) {
  return apply1(uppercase_ascii, s);
}
function uncapitalize_ascii(s) {
  return apply1(lowercase_ascii, s);
}
function to_seq(s) {
  const aux = function(i, param) {
    if (i === s.length) {
      return (
        /* Nil */
        0
      );
    }
    const x = get(s, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: (
        /* Cons */
        0
      ),
      _0: x,
      _1: function(param2) {
        return aux(partial_arg, param2);
      }
    };
  };
  return function(param) {
    return aux(0, param);
  };
}
function to_seqi(s) {
  const aux = function(i, param) {
    if (i === s.length) {
      return (
        /* Nil */
        0
      );
    }
    const x = get(s, i);
    const partial_arg = i + 1 | 0;
    return {
      TAG: (
        /* Cons */
        0
      ),
      _0: [
        i,
        x
      ],
      _1: function(param2) {
        return aux(partial_arg, param2);
      }
    };
  };
  return function(param) {
    return aux(0, param);
  };
}
function of_seq(i) {
  const n = {
    contents: 0
  };
  const buf = {
    contents: make3(
      256,
      /* '\000' */
      0
    )
  };
  const resize = function(param) {
    const new_len = min(buf.contents.length << 1, max_string_length);
    if (buf.contents.length === new_len) {
      throw new MelangeError("Failure", {
        MEL_EXN_ID: "Failure",
        _1: "Bytes.of_seq: cannot grow bytes"
      });
    }
    const new_buf = make3(
      new_len,
      /* '\000' */
      0
    );
    blit(buf.contents, 0, new_buf, 0, n.contents);
    buf.contents = new_buf;
  };
  iter(function(c) {
    if (n.contents === buf.contents.length) {
      resize(void 0);
    }
    set(buf.contents, n.contents, c);
    n.contents = n.contents + 1 | 0;
  }, i);
  return sub(buf.contents, 0, n.contents);
}
function unsafe_get_uint16_le(b, i) {
  if (big_endian) {
    return bswap16(get16u(b, i));
  } else {
    return get16u(b, i);
  }
}
function unsafe_get_uint16_be(b, i) {
  if (big_endian) {
    return get16u(b, i);
  } else {
    return bswap16(get16u(b, i));
  }
}
function get_int8(b, i) {
  return get(b, i) << (int_size - 8 | 0) >> (int_size - 8 | 0);
}
function get_uint16_le(b, i) {
  if (big_endian) {
    return bswap16(get16(b, i));
  } else {
    return get16(b, i);
  }
}
function get_uint16_be(b, i) {
  if (big_endian) {
    return get16(b, i);
  } else {
    return bswap16(get16(b, i));
  }
}
function get_int16_ne(b, i) {
  return get16(b, i) << (int_size - 16 | 0) >> (int_size - 16 | 0);
}
function get_int16_le(b, i) {
  return get_uint16_le(b, i) << (int_size - 16 | 0) >> (int_size - 16 | 0);
}
function get_int16_be(b, i) {
  return get_uint16_be(b, i) << (int_size - 16 | 0) >> (int_size - 16 | 0);
}
function get_int32_le(b, i) {
  if (big_endian) {
    return bswap32(get32(b, i));
  } else {
    return get32(b, i);
  }
}
function get_int32_be(b, i) {
  if (big_endian) {
    return get32(b, i);
  } else {
    return bswap32(get32(b, i));
  }
}
function get_int64_le(b, i) {
  if (big_endian) {
    return bswap64(get64(b, i));
  } else {
    return get64(b, i);
  }
}
function get_int64_be(b, i) {
  if (big_endian) {
    return get64(b, i);
  } else {
    return bswap64(get64(b, i));
  }
}
function get_utf_8_uchar(b, i) {
  const b0 = get(b, i);
  const max = b.length - 1 | 0;
  let exit = 0;
  if (b0 >= 224) {
    if (b0 >= 237) {
      if (b0 >= 245) {
        return 16842749;
      }
      switch (b0) {
        case 237:
          const i$1 = i + 1 | 0;
          if (i$1 > max) {
            return 16842749;
          }
          const b1 = b[i$1];
          if (b1 >>> 5 !== 4) {
            return 16842749;
          }
          const i$2 = i$1 + 1 | 0;
          if (i$2 > max) {
            return 33619965;
          }
          const b2 = b[i$2];
          if (b2 >>> 6 !== 2) {
            return 33619965;
          }
          const u = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
          return 184549376 | u;
        case 238:
        case 239:
          exit = 1;
          break;
        case 240:
          const i$3 = i + 1 | 0;
          if (i$3 > max) {
            return 16842749;
          }
          const b1$1 = b[i$3];
          if (b1$1 < 144 || 191 < b1$1) {
            return 16842749;
          }
          const i$4 = i$3 + 1 | 0;
          if (i$4 > max) {
            return 33619965;
          }
          const b2$1 = b[i$4];
          if (b2$1 >>> 6 !== 2) {
            return 33619965;
          }
          const i$5 = i$4 + 1 | 0;
          if (i$5 > max) {
            return 50397181;
          }
          const b3 = b[i$5];
          if (b3 >>> 6 !== 2) {
            return 50397181;
          }
          const u$1 = (b0 & 7) << 18 | (b1$1 & 63) << 12 | (b2$1 & 63) << 6 | b3 & 63;
          return 201326592 | u$1;
        case 241:
        case 242:
        case 243:
          exit = 2;
          break;
        case 244:
          const i$6 = i + 1 | 0;
          if (i$6 > max) {
            return 16842749;
          }
          const b1$2 = b[i$6];
          if (b1$2 >>> 4 !== 8) {
            return 16842749;
          }
          const i$7 = i$6 + 1 | 0;
          if (i$7 > max) {
            return 33619965;
          }
          const b2$2 = b[i$7];
          if (b2$2 >>> 6 !== 2) {
            return 33619965;
          }
          const i$8 = i$7 + 1 | 0;
          if (i$8 > max) {
            return 50397181;
          }
          const b3$1 = b[i$8];
          if (b3$1 >>> 6 !== 2) {
            return 50397181;
          }
          const u$2 = (b0 & 7) << 18 | (b1$2 & 63) << 12 | (b2$2 & 63) << 6 | b3$1 & 63;
          return 201326592 | u$2;
      }
    } else if (b0 >= 225) {
      exit = 1;
    } else {
      const i$9 = i + 1 | 0;
      if (i$9 > max) {
        return 16842749;
      }
      const b1$3 = b[i$9];
      if (b1$3 >>> 5 !== 5) {
        return 16842749;
      }
      const i$10 = i$9 + 1 | 0;
      if (i$10 > max) {
        return 33619965;
      }
      const b2$3 = b[i$10];
      if (b2$3 >>> 6 !== 2) {
        return 33619965;
      }
      const u$3 = (b0 & 15) << 12 | (b1$3 & 63) << 6 | b2$3 & 63;
      return 184549376 | u$3;
    }
  } else {
    if (b0 < 128) {
      return 150994944 | b0;
    }
    if (b0 < 194) {
      return 16842749;
    }
    const i$11 = i + 1 | 0;
    if (i$11 > max) {
      return 16842749;
    }
    const b1$4 = b[i$11];
    if (b1$4 >>> 6 !== 2) {
      return 16842749;
    }
    const u$4 = (b0 & 31) << 6 | b1$4 & 63;
    return 167772160 | u$4;
  }
  switch (exit) {
    case 1:
      const i$12 = i + 1 | 0;
      if (i$12 > max) {
        return 16842749;
      }
      const b1$5 = b[i$12];
      if (b1$5 >>> 6 !== 2) {
        return 16842749;
      }
      const i$13 = i$12 + 1 | 0;
      if (i$13 > max) {
        return 33619965;
      }
      const b2$4 = b[i$13];
      if (b2$4 >>> 6 !== 2) {
        return 33619965;
      }
      const u$5 = (b0 & 15) << 12 | (b1$5 & 63) << 6 | b2$4 & 63;
      return 184549376 | u$5;
    case 2:
      const i$14 = i + 1 | 0;
      if (i$14 > max) {
        return 16842749;
      }
      const b1$6 = b[i$14];
      if (b1$6 >>> 6 !== 2) {
        return 16842749;
      }
      const i$15 = i$14 + 1 | 0;
      if (i$15 > max) {
        return 33619965;
      }
      const b2$5 = b[i$15];
      if (b2$5 >>> 6 !== 2) {
        return 33619965;
      }
      const i$16 = i$15 + 1 | 0;
      if (i$16 > max) {
        return 50397181;
      }
      const b3$2 = b[i$16];
      if (b3$2 >>> 6 !== 2) {
        return 50397181;
      }
      const u$6 = (b0 & 7) << 18 | (b1$6 & 63) << 12 | (b2$5 & 63) << 6 | b3$2 & 63;
      return 201326592 | u$6;
  }
}
function is_valid_utf_8(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    const match = b[i];
    let exit = 0;
    if (match >= 224) {
      if (match >= 237) {
        if (match >= 245) {
          return false;
        }
        switch (match) {
          case 237:
            const last = i + 2 | 0;
            if (last > max || b[i + 1 | 0] >>> 5 !== 4 || b[last] >>> 6 !== 2) {
              return false;
            }
            _i = last + 1 | 0;
            continue;
          case 238:
          case 239:
            exit = 1;
            break;
          case 240:
            const last$1 = i + 3 | 0;
            let tmp = true;
            if (last$1 <= max) {
              const b$1 = b[i + 1 | 0];
              tmp = b$1 < 144 || 191 < b$1 || b[i + 2 | 0] >>> 6 !== 2 || b[last$1] >>> 6 !== 2;
            }
            if (tmp) {
              return false;
            }
            _i = last$1 + 1 | 0;
            continue;
          case 241:
          case 242:
          case 243:
            exit = 2;
            break;
          case 244:
            const last$2 = i + 3 | 0;
            if (last$2 > max || b[i + 1 | 0] >>> 4 !== 8 || b[i + 2 | 0] >>> 6 !== 2 || b[last$2] >>> 6 !== 2) {
              return false;
            }
            _i = last$2 + 1 | 0;
            continue;
        }
      } else if (match >= 225) {
        exit = 1;
      } else {
        const last$3 = i + 2 | 0;
        if (last$3 > max || b[i + 1 | 0] >>> 5 !== 5 || b[last$3] >>> 6 !== 2) {
          return false;
        }
        _i = last$3 + 1 | 0;
        continue;
      }
    } else {
      if (match >= 128) {
        if (match < 194) {
          return false;
        }
        const last$4 = i + 1 | 0;
        if (last$4 > max || b[last$4] >>> 6 !== 2) {
          return false;
        }
        _i = last$4 + 1 | 0;
        continue;
      }
      _i = i + 1 | 0;
      continue;
    }
    switch (exit) {
      case 1:
        const last$5 = i + 2 | 0;
        if (last$5 > max || b[i + 1 | 0] >>> 6 !== 2 || b[last$5] >>> 6 !== 2) {
          return false;
        }
        _i = last$5 + 1 | 0;
        continue;
      case 2:
        const last$6 = i + 3 | 0;
        if (last$6 > max || b[i + 1 | 0] >>> 6 !== 2 || b[i + 2 | 0] >>> 6 !== 2 || b[last$6] >>> 6 !== 2) {
          return false;
        }
        _i = last$6 + 1 | 0;
        continue;
    }
  }
  ;
}
function get_utf_16be_uchar(b, i) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  if (i === max) {
    return 16842749;
  }
  const u = unsafe_get_uint16_be(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  const last = i + 3 | 0;
  if (last > max) {
    return ((max - i | 0) + 1 | 0) << 24 | 65533;
  }
  const u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  const u$2 = ((u & 1023) << 10 | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}
function is_valid_utf_16be(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    const u = unsafe_get_uint16_be(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue;
    }
    if (u > 56319) {
      return false;
    }
    const last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    const u$1 = unsafe_get_uint16_be(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue;
  }
  ;
}
function get_utf_16le_uchar(b, i) {
  const max = b.length - 1 | 0;
  if (i < 0 || i > max) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  if (i === max) {
    return 16842749;
  }
  const u = unsafe_get_uint16_le(b, i);
  if (u < 55296 || u > 57343) {
    return 167772160 | u;
  }
  if (u > 56319) {
    return 33619965;
  }
  const last = i + 3 | 0;
  if (last > max) {
    return ((max - i | 0) + 1 | 0) << 24 | 65533;
  }
  const u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
  if (u$1 < 56320 || u$1 > 57343) {
    return 33619965;
  }
  const u$2 = ((u & 1023) << 10 | u$1 & 1023) + 65536 | 0;
  return 201326592 | u$2;
}
function is_valid_utf_16le(b) {
  let max = b.length - 1 | 0;
  let _i = 0;
  while (true) {
    const i = _i;
    if (i > max) {
      return true;
    }
    if (i === max) {
      return false;
    }
    const u = unsafe_get_uint16_le(b, i);
    if (u < 55296 || u > 57343) {
      _i = i + 2 | 0;
      continue;
    }
    if (u > 56319) {
      return false;
    }
    const last = i + 3 | 0;
    if (last > max) {
      return false;
    }
    const u$1 = unsafe_get_uint16_le(b, i + 2 | 0);
    if (u$1 < 56320 || u$1 > 57343) {
      return false;
    }
    _i = i + 4 | 0;
    continue;
  }
  ;
}

// _build/default/src/output/node_modules/melange/string.js
function make4(n, c) {
  return bytes_to_string(make3(n, c));
}
function init2(n, f) {
  return bytes_to_string(init(n, f));
}
function sub2(s, ofs, len) {
  return bytes_to_string(sub(bytes_of_string(s), ofs, len));
}
function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new MelangeError("Invalid_argument", {
    MEL_EXN_ID: "Invalid_argument",
    _1: "String.concat"
  });
}
function sum_lengths(_acc, seplen, _param) {
  while (true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    const hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue;
  }
  ;
}
function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while (true) {
    const param = _param;
    const pos = _pos;
    if (!param) {
      return dst;
    }
    const hd = param.hd;
    if (param.tl) {
      caml_blit_string(hd, 0, dst, pos, hd.length);
      caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue;
    }
    caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  }
  ;
}
function concat(sep, l) {
  if (!l) {
    return "";
  }
  const seplen = sep.length;
  return bytes_to_string(unsafe_blits(caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l));
}
function cat(prim0, prim1) {
  return prim0 + prim1;
}
function iter2(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    _1(f, s.charCodeAt(i));
  }
}
function iteri(f, s) {
  for (let i = 0, i_finish = s.length; i < i_finish; ++i) {
    _2(f, i, s.charCodeAt(i));
  }
}
function map2(f, s) {
  return bytes_to_string(map(f, bytes_of_string(s)));
}
function mapi2(f, s) {
  return bytes_to_string(mapi(f, bytes_of_string(s)));
}
function fold_right2(f, x, a) {
  return fold_right(f, bytes_of_string(x), a);
}
function fold_left3(f, a, x) {
  return fold_left2(f, a, bytes_of_string(x));
}
function exists2(f, s) {
  return exists(f, bytes_of_string(s));
}
function for_all2(f, s) {
  return for_all(f, bytes_of_string(s));
}
function is_space2(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}
function trim2(s) {
  if (s === "" || !(is_space2(s.charCodeAt(0)) || is_space2(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return bytes_to_string(trim(bytes_of_string(s)));
  }
}
function escaped(s) {
  const b = bytes_of_string(s);
  const b$p = unsafe_escape(b);
  if (b === b$p) {
    return s;
  } else {
    return bytes_to_string(b$p);
  }
}
function index_rec(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      throw new MelangeError(Not_found, {
        MEL_EXN_ID: Not_found
      });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function index(s, c) {
  return index_rec(s, s.length, 0, c);
}
function index_rec_opt(s, lim, _i, c) {
  while (true) {
    const i = _i;
    if (i >= lim) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}
function index_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.index_from / Bytes.index_from"
    });
  }
  return index_rec(s, l, i, c);
}
function index_from_opt(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.index_from_opt / Bytes.index_from_opt"
    });
  }
  return index_rec_opt(s, l, i, c);
}
function rindex_rec(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      throw new MelangeError(Not_found, {
        MEL_EXN_ID: Not_found
      });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  }
  ;
}
function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}
function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.rindex_from / Bytes.rindex_from"
    });
  }
  return rindex_rec(s, i, c);
}
function rindex_rec_opt(s, _i, c) {
  while (true) {
    const i = _i;
    if (i < 0) {
      return;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue;
  }
  ;
}
function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}
function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.rindex_from_opt / Bytes.rindex_from_opt"
    });
  }
  return rindex_rec_opt(s, i, c);
}
function contains_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.contains_from / Bytes.contains_from"
    });
  }
  try {
    index_rec(s, l, i, c);
    return true;
  } catch (raw_exn) {
    const exn = internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Not_found) {
      return false;
    }
    throw exn;
  }
}
function contains(s, c) {
  return contains_from(s, 0, c);
}
function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.rcontains_from / Bytes.rcontains_from"
    });
  }
  try {
    rindex_rec(s, i, c);
    return true;
  } catch (raw_exn) {
    const exn = internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Not_found) {
      return false;
    }
    throw exn;
  }
}
function uppercase_ascii3(s) {
  return bytes_to_string(uppercase_ascii2(bytes_of_string(s)));
}
function lowercase_ascii3(s) {
  return bytes_to_string(lowercase_ascii2(bytes_of_string(s)));
}
function capitalize_ascii2(s) {
  return bytes_to_string(capitalize_ascii(bytes_of_string(s)));
}
function uncapitalize_ascii2(s) {
  return bytes_to_string(uncapitalize_ascii(bytes_of_string(s)));
}
function starts_with(prefix, s) {
  const len_s = s.length;
  const len_pre = prefix.length;
  if (len_s >= len_pre) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s.charCodeAt(i) !== prefix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    }
    ;
  } else {
    return false;
  }
}
function ends_with(suffix, s) {
  const len_s = s.length;
  const len_suf = suffix.length;
  const diff = len_s - len_suf | 0;
  if (diff >= 0) {
    let _i = 0;
    while (true) {
      const i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s.charCodeAt(diff + i | 0) !== suffix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue;
    }
    ;
  } else {
    return false;
  }
}
function hash(x) {
  return resolve("caml_string_hash")(0, x);
}
function split_on_char(sep, s) {
  let r = (
    /* [] */
    0
  );
  let j = s.length;
  for (let i = s.length - 1 | 0; i >= 0; --i) {
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub2(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
  }
  return {
    hd: sub2(s, 0, j),
    tl: r
  };
}
var compare = caml_string_compare;
function to_seq2(s) {
  return to_seq(bytes_of_string(s));
}
function to_seqi2(s) {
  return to_seqi(bytes_of_string(s));
}
function of_seq2(g) {
  return bytes_to_string(of_seq(g));
}
function get_utf_8_uchar2(s, i) {
  return get_utf_8_uchar(bytes_of_string(s), i);
}
function is_valid_utf_82(s) {
  return is_valid_utf_8(bytes_of_string(s));
}
function get_utf_16be_uchar2(s, i) {
  return get_utf_16be_uchar(bytes_of_string(s), i);
}
function is_valid_utf_16be2(s) {
  return is_valid_utf_16be(bytes_of_string(s));
}
function get_utf_16le_uchar2(s, i) {
  return get_utf_16le_uchar(bytes_of_string(s), i);
}
function is_valid_utf_16le2(s) {
  return is_valid_utf_16le(bytes_of_string(s));
}
function get_int82(s, i) {
  return get_int8(bytes_of_string(s), i);
}
function get_uint16_le2(s, i) {
  return get_uint16_le(bytes_of_string(s), i);
}
function get_uint16_be2(s, i) {
  return get_uint16_be(bytes_of_string(s), i);
}
function get_int16_ne2(s, i) {
  return get_int16_ne(bytes_of_string(s), i);
}
function get_int16_le2(s, i) {
  return get_int16_le(bytes_of_string(s), i);
}
function get_int16_be2(s, i) {
  return get_int16_be(bytes_of_string(s), i);
}
function get_int32_le2(s, i) {
  return get_int32_le(bytes_of_string(s), i);
}
function get_int32_be2(s, i) {
  return get_int32_be(bytes_of_string(s), i);
}
function get_int64_le2(s, i) {
  return get_int64_le(bytes_of_string(s), i);
}
function get_int64_be2(s, i) {
  return get_int64_be(bytes_of_string(s), i);
}
var empty2 = "";
var of_bytes = to_string;
var to_bytes = of_string;
var blit2 = blit_string;
function equal(prim0, prim1) {
  return prim0 === prim1;
}
var get_uint8 = get2;
var get_uint16_ne = get16;
var get_int32_ne = get32;
function seeded_hash(prim0, prim1) {
  return resolve("caml_string_hash")(prim0, prim1);
}
var get_int64_ne = get64;

export {
  fold_left,
  make4 as make,
  init2 as init,
  sub2 as sub,
  concat,
  cat,
  iter2 as iter,
  iteri,
  map2 as map,
  mapi2 as mapi,
  fold_right2 as fold_right,
  fold_left3 as fold_left2,
  exists2 as exists,
  for_all2 as for_all,
  trim2 as trim,
  escaped,
  index,
  index_opt,
  index_from,
  index_from_opt,
  rindex,
  rindex_from,
  rindex_opt,
  rindex_from_opt,
  contains_from,
  contains,
  rcontains_from,
  uppercase_ascii3 as uppercase_ascii,
  lowercase_ascii3 as lowercase_ascii,
  capitalize_ascii2 as capitalize_ascii,
  uncapitalize_ascii2 as uncapitalize_ascii,
  starts_with,
  ends_with,
  hash,
  split_on_char,
  compare,
  to_seq2 as to_seq,
  to_seqi2 as to_seqi,
  of_seq2 as of_seq,
  get_utf_8_uchar2 as get_utf_8_uchar,
  is_valid_utf_82 as is_valid_utf_8,
  get_utf_16be_uchar2 as get_utf_16be_uchar,
  is_valid_utf_16be2 as is_valid_utf_16be,
  get_utf_16le_uchar2 as get_utf_16le_uchar,
  is_valid_utf_16le2 as is_valid_utf_16le,
  get_int82 as get_int8,
  get_uint16_le2 as get_uint16_le,
  get_uint16_be2 as get_uint16_be,
  get_int16_ne2 as get_int16_ne,
  get_int16_le2 as get_int16_le,
  get_int16_be2 as get_int16_be,
  get_int32_le2 as get_int32_le,
  get_int32_be2 as get_int32_be,
  get_int64_le2 as get_int64_le,
  get_int64_be2 as get_int64_be,
  empty2 as empty,
  of_bytes,
  to_bytes,
  blit2 as blit,
  equal,
  get_uint8,
  get_uint16_ne,
  get_int32_ne,
  seeded_hash,
  get_int64_ne
};
//# sourceMappingURL=chunk-GSNAPODV.js.map
