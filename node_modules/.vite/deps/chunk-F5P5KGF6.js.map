{
  "version": 3,
  "sources": ["../../../_build/default/src/output/node_modules/melange.js/caml_obj.js"],
  "sourcesContent": ["// Generated by Melange\n\nimport * as Caml from \"melange.js/caml.js\";\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\n\nconst for_in = (function(o,foo){\n        for (var x in o) { foo(x) }}\n);\n\nconst caml_obj_dup = (function(x){\n  if(Array.isArray(x)){\n    var len = x.length\n    var v = new Array(len)\n    for(var i = 0 ; i < len ; ++i){\n      v[i] = x[i]\n    }\n    if(x.TAG !== undefined){\n      v.TAG = x.TAG // TODO this can be removed eventually\n    }\n    return v\n  }\n  return Object.assign({},x)\n}\n);\n\nconst update_dummy = (function(x,y){\n  var k\n  if(Array.isArray(y)){\n    for(k = 0; k < y.length ; ++k){\n      x[k] = y[k]\n    }\n    if(y.TAG !== undefined){\n      x.TAG = y.TAG\n    }\n  } else {\n    for (var k in y){\n      x[k] = y[k]\n    }\n  }\n}\n);\n\nfunction caml_compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  const a_type = typeof a;\n  const b_type = typeof b;\n  switch (a_type) {\n    case \"bigint\" :\n      if (b_type === \"bigint\") {\n        return Caml.caml_float_compare(a, b);\n      }\n      break;\n    case \"boolean\" :\n      if (b_type === \"boolean\") {\n        return Caml.caml_int_compare(a, b);\n      }\n      break;\n    case \"function\" :\n      if (b_type === \"function\") {\n        throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n            MEL_EXN_ID: \"Invalid_argument\",\n            _1: \"compare: functional value\"\n          });\n      }\n      break;\n    case \"number\" :\n      if (b_type === \"number\") {\n        return Caml.caml_float_compare(a, b);\n      }\n      break;\n    case \"string\" :\n      if (b_type === \"string\") {\n        return Caml.caml_string_compare(a, b);\n      } else {\n        return 1;\n      }\n    case \"undefined\" :\n      return -1;\n  }\n  switch (b_type) {\n    case \"string\" :\n      return -1;\n    case \"undefined\" :\n      return 1;\n    default:\n      if (a_type === \"boolean\") {\n        return 1;\n      }\n      if (b_type === \"boolean\") {\n        return -1;\n      }\n      if (a_type === \"function\") {\n        return 1;\n      }\n      if (b_type === \"function\") {\n        return -1;\n      }\n      if (a_type === \"number\") {\n        if (b === null || b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      if (b_type === \"number\") {\n        if (a === null || a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      if (a === null) {\n        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      if (b === null) {\n        if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      if (a.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n        if (b.MEL_PRIVATE_NESTED_SOME_NONE !== undefined) {\n          return aux_obj_compare(a, b);\n        } else {\n          return -1;\n        }\n      }\n      const tag_a = a.TAG;\n      const tag_b = b.TAG;\n      if (tag_a === 248) {\n        return Caml.caml_int_compare(a[1], b[1]);\n      }\n      if (tag_a === 251) {\n        throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n            MEL_EXN_ID: \"Invalid_argument\",\n            _1: \"equal: abstract value\"\n          });\n      }\n      if (tag_a !== tag_b) {\n        if (tag_a < tag_b) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      const len_a = a.length | 0;\n      const len_b = b.length | 0;\n      if (len_a === len_b) {\n        if (Array.isArray(a)) {\n          let _i = 0;\n          while (true) {\n            const i = _i;\n            if (i === len_a) {\n              return 0;\n            }\n            const res = caml_compare(a[i], b[i]);\n            if (res !== 0) {\n              return res;\n            }\n            _i = i + 1 | 0;\n            continue;\n          };\n        } else if ((a instanceof Date && b instanceof Date\n          )) {\n          return (a - b\n          );\n        } else {\n          return aux_obj_compare(a, b);\n        }\n      } else if (len_a < len_b) {\n        let _i$1 = 0;\n        while (true) {\n          const i$1 = _i$1;\n          if (i$1 === len_a) {\n            return -1;\n          }\n          const res$1 = caml_compare(a[i$1], b[i$1]);\n          if (res$1 !== 0) {\n            return res$1;\n          }\n          _i$1 = i$1 + 1 | 0;\n          continue;\n        };\n      } else {\n        let _i$2 = 0;\n        while (true) {\n          const i$2 = _i$2;\n          if (i$2 === len_b) {\n            return 1;\n          }\n          const res$2 = caml_compare(a[i$2], b[i$2]);\n          if (res$2 !== 0) {\n            return res$2;\n          }\n          _i$2 = i$2 + 1 | 0;\n          continue;\n        };\n      }\n  }\n}\n\nfunction aux_obj_compare(a, b) {\n  const min_key_lhs = {\n    contents: undefined\n  };\n  const min_key_rhs = {\n    contents: undefined\n  };\n  const do_key = function (param, key) {\n    const min_key = param[2];\n    const b = param[1];\n    if (!(!Object.prototype.hasOwnProperty.call(b, key) || caml_compare(param[0][key], b[key]) > 0)) {\n      return;\n    }\n    const mk = min_key.contents;\n    if (mk !== undefined && key >= mk) {\n      return;\n    } else {\n      min_key.contents = key;\n      return;\n    }\n  };\n  const partial_arg = [\n    a,\n    b,\n    min_key_rhs\n  ];\n  const do_key_a = function (param) {\n    return do_key(partial_arg, param);\n  };\n  const partial_arg$1 = [\n    b,\n    a,\n    min_key_lhs\n  ];\n  const do_key_b = function (param) {\n    return do_key(partial_arg$1, param);\n  };\n  for_in(a, do_key_a);\n  for_in(b, do_key_b);\n  const match = min_key_lhs.contents;\n  const match$1 = min_key_rhs.contents;\n  if (match !== undefined) {\n    if (match$1 !== undefined) {\n      return Caml.caml_string_compare(match, match$1);\n    } else {\n      return -1;\n    }\n  } else if (match$1 !== undefined) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_equal(a, b) {\n  if (a === b) {\n    return true;\n  }\n  const a_type = typeof a;\n  if (a_type === \"string\" || a_type === \"number\" || a_type === \"bigint\" || a_type === \"boolean\" || a_type === \"undefined\" || a === null) {\n    return false;\n  }\n  const b_type = typeof b;\n  if (a_type === \"function\" || b_type === \"function\") {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"equal: functional value\"\n      });\n  }\n  if (b_type === \"number\" || b_type === \"bigint\" || b_type === \"undefined\" || b === null) {\n    return false;\n  }\n  const tag_a = a.TAG;\n  const tag_b = b.TAG;\n  if (tag_a === 248) {\n    return a[1] === b[1];\n  }\n  if (tag_a === 251) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"equal: abstract value\"\n      });\n  }\n  if (tag_a !== tag_b) {\n    return false;\n  }\n  const len_a = a.length | 0;\n  const len_b = b.length | 0;\n  if (len_a === len_b) {\n    if (Array.isArray(a)) {\n      let _i = 0;\n      while (true) {\n        const i = _i;\n        if (i === len_a) {\n          return true;\n        }\n        if (!caml_equal(a[i], b[i])) {\n          return false;\n        }\n        _i = i + 1 | 0;\n        continue;\n      };\n    } else if ((a instanceof Date && b instanceof Date\n      )) {\n      return !(a > b || a < b);\n    } else {\n      const result = {\n        contents: true\n      };\n      const do_key_a = function (key) {\n        if (!Object.prototype.hasOwnProperty.call(b, key)) {\n          result.contents = false;\n          return;\n        }\n        \n      };\n      const do_key_b = function (key) {\n        if (!Object.prototype.hasOwnProperty.call(a, key) || !caml_equal(b[key], a[key])) {\n          result.contents = false;\n          return;\n        }\n        \n      };\n      for_in(a, do_key_a);\n      if (result.contents) {\n        for_in(b, do_key_b);\n      }\n      return result.contents;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction caml_equal_null(x, y) {\n  if (y !== null) {\n    return caml_equal(x, y);\n  } else {\n    return x === y;\n  }\n}\n\nfunction caml_equal_undefined(x, y) {\n  if (y !== undefined) {\n    return caml_equal(x, y);\n  } else {\n    return x === y;\n  }\n}\n\nfunction caml_equal_nullable(x, y) {\n  if (y == null) {\n    return x === y;\n  } else {\n    return caml_equal(x, y);\n  }\n}\n\nfunction caml_notequal(a, b) {\n  if ((typeof a === \"number\" || typeof a === \"bigint\") && (typeof b === \"number\" || typeof b === \"bigint\")) {\n    return a !== b;\n  } else {\n    return !caml_equal(a, b);\n  }\n}\n\nfunction caml_greaterequal(a, b) {\n  if ((typeof a === \"number\" || typeof a === \"bigint\") && (typeof b === \"number\" || typeof b === \"bigint\")) {\n    return a >= b;\n  } else {\n    return caml_compare(a, b) >= 0;\n  }\n}\n\nfunction caml_greaterthan(a, b) {\n  if ((typeof a === \"number\" || typeof a === \"bigint\") && (typeof b === \"number\" || typeof b === \"bigint\")) {\n    return a > b;\n  } else {\n    return caml_compare(a, b) > 0;\n  }\n}\n\nfunction caml_lessequal(a, b) {\n  if ((typeof a === \"number\" || typeof a === \"bigint\") && (typeof b === \"number\" || typeof b === \"bigint\")) {\n    return a <= b;\n  } else {\n    return caml_compare(a, b) <= 0;\n  }\n}\n\nfunction caml_lessthan(a, b) {\n  if ((typeof a === \"number\" || typeof a === \"bigint\") && (typeof b === \"number\" || typeof b === \"bigint\")) {\n    return a < b;\n  } else {\n    return caml_compare(a, b) < 0;\n  }\n}\n\nfunction caml_min(x, y) {\n  if (caml_compare(x, y) <= 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_max(x, y) {\n  if (caml_compare(x, y) >= 0) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nexport {\n  caml_obj_dup,\n  update_dummy,\n  caml_compare,\n  caml_equal,\n  caml_equal_null,\n  caml_equal_undefined,\n  caml_equal_nullable,\n  caml_notequal,\n  caml_greaterequal,\n  caml_greaterthan,\n  caml_lessthan,\n  caml_lessequal,\n  caml_min,\n  caml_max,\n}\n/* No side effect */\n"],
  "mappings": ";;;;;AAKA,IAAM,UAAU,SAAS,GAAE,KAAI;AACvB,WAAS,KAAK,GAAG;AAAE,QAAI,CAAC;AAAA,EAAE;AAAC;AAgQnC,SAAS,WAAW,GAAG,GAAG;AACxB,MAAI,MAAM,GAAG;AACX,WAAO;AAAA,EACT;AACA,QAAM,SAAS,OAAO;AACtB,MAAI,WAAW,YAAY,WAAW,YAAY,WAAW,YAAY,WAAW,aAAa,WAAW,eAAe,MAAM,MAAM;AACrI,WAAO;AAAA,EACT;AACA,QAAM,SAAS,OAAO;AACtB,MAAI,WAAW,cAAc,WAAW,YAAY;AAClD,UAAM,IAAuB,aAAa,oBAAoB;AAAA,MAC1D,YAAY;AAAA,MACZ,IAAI;AAAA,IACN,CAAC;AAAA,EACL;AACA,MAAI,WAAW,YAAY,WAAW,YAAY,WAAW,eAAe,MAAM,MAAM;AACtF,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,EAAE;AAChB,QAAM,QAAQ,EAAE;AAChB,MAAI,UAAU,KAAK;AACjB,WAAO,EAAE,CAAC,MAAM,EAAE,CAAC;AAAA,EACrB;AACA,MAAI,UAAU,KAAK;AACjB,UAAM,IAAuB,aAAa,oBAAoB;AAAA,MAC1D,YAAY;AAAA,MACZ,IAAI;AAAA,IACN,CAAC;AAAA,EACL;AACA,MAAI,UAAU,OAAO;AACnB,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,EAAE,SAAS;AACzB,QAAM,QAAQ,EAAE,SAAS;AACzB,MAAI,UAAU,OAAO;AACnB,QAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,UAAI,KAAK;AACT,aAAO,MAAM;AACX,cAAM,IAAI;AACV,YAAI,MAAM,OAAO;AACf,iBAAO;AAAA,QACT;AACA,YAAI,CAAC,WAAW,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG;AAC3B,iBAAO;AAAA,QACT;AACA,aAAK,IAAI,IAAI;AACb;AAAA,MACF;AAAC;AAAA,IACH,WAAY,aAAa,QAAQ,aAAa,MACzC;AACH,aAAO,EAAE,IAAI,KAAK,IAAI;AAAA,IACxB,OAAO;AACL,YAAM,SAAS;AAAA,QACb,UAAU;AAAA,MACZ;AACA,YAAM,WAAW,SAAU,KAAK;AAC9B,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,GAAG,GAAG;AACjD,iBAAO,WAAW;AAClB;AAAA,QACF;AAAA,MAEF;AACA,YAAM,WAAW,SAAU,KAAK;AAC9B,YAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,GAAG,KAAK,CAAC,WAAW,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG;AAChF,iBAAO,WAAW;AAClB;AAAA,QACF;AAAA,MAEF;AACA,aAAO,GAAG,QAAQ;AAClB,UAAI,OAAO,UAAU;AACnB,eAAO,GAAG,QAAQ;AAAA,MACpB;AACA,aAAO,OAAO;AAAA,IAChB;AAAA,EACF,OAAO;AACL,WAAO;AAAA,EACT;AACF;",
  "names": []
}
