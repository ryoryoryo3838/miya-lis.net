{
  "version": 3,
  "sources": ["../../../_build/default/src/output/node_modules/melange.js/caml.js", "../../../_build/default/src/output/node_modules/melange.js/caml_int64.js", "../../../_build/default/src/output/node_modules/melange.js/caml_bytes.js", "../../../_build/default/src/output/node_modules/melange.js/caml_external_polyfill.js", "../../../_build/default/src/output/node_modules/melange.js/caml_string.js", "../../../_build/default/src/output/node_modules/melange.js/caml_sys.js", "../../../_build/default/src/output/node_modules/melange/stdlib.js"],
  "sourcesContent": ["// Generated by Melange\n\n\nfunction caml_int_compare(x, y) {\n  if (x < y) {\n    return -1;\n  } else if (x === y) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_compare(x, y) {\n  if (x) {\n    if (y) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else if (y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_float_compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else if (x > y || x === x) {\n    return 1;\n  } else if (y === y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_string_compare(s1, s2) {\n  if (s1 === s2) {\n    return 0;\n  } else if (s1 < s2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_min(x, y) {\n  if (x) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction caml_int_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_bool_max(x, y) {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction i64_eq(x, y) {\n  if (x[1] === y[1]) {\n    return x[0] === y[0];\n  } else {\n    return false;\n  }\n}\n\nfunction i64_ge(param, param$1) {\n  const other_hi = param$1[0];\n  const hi = param[0];\n  if (hi > other_hi) {\n    return true;\n  } else if (hi < other_hi) {\n    return false;\n  } else {\n    return param[1] >= param$1[1];\n  }\n}\n\nfunction i64_neq(x, y) {\n  return !i64_eq(x, y);\n}\n\nfunction i64_lt(x, y) {\n  return !i64_ge(x, y);\n}\n\nfunction i64_gt(x, y) {\n  if (x[0] > y[0]) {\n    return true;\n  } else if (x[0] < y[0]) {\n    return false;\n  } else {\n    return x[1] > y[1];\n  }\n}\n\nfunction i64_le(x, y) {\n  return !i64_gt(x, y);\n}\n\nfunction i64_min(x, y) {\n  if (i64_ge(x, y)) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction i64_max(x, y) {\n  if (i64_gt(x, y)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nexport {\n  caml_int_compare,\n  caml_bool_compare,\n  caml_float_compare,\n  caml_string_compare,\n  caml_bool_min,\n  caml_int_min,\n  caml_float_min,\n  caml_string_min,\n  caml_int32_min,\n  caml_bool_max,\n  caml_int_max,\n  caml_float_max,\n  caml_string_max,\n  caml_int32_max,\n  i64_eq,\n  i64_neq,\n  i64_lt,\n  i64_gt,\n  i64_le,\n  i64_ge,\n  i64_min,\n  i64_max,\n}\n/* No side effect */\n", "// Generated by Melange\n\nimport * as Caml from \"./caml.js\";\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\n\nfunction mk(lo, hi) {\n  return [\n    hi,\n    (lo >>> 0)\n  ];\n}\n\nconst min_int = [\n  -2147483648,\n  0\n];\n\nconst max_int = [\n  2147483647,\n  4294967295\n];\n\nconst one = [\n  0,\n  1\n];\n\nconst zero = [\n  0,\n  0\n];\n\nconst neg_one = [\n  -1,\n  4294967295\n];\n\nfunction neg_signed(x) {\n  return (x & -2147483648) !== 0;\n}\n\nfunction non_neg_signed(x) {\n  return (x & -2147483648) === 0;\n}\n\nfunction succ(param) {\n  let x_lo = param[1];\n  let x_hi = param[0];\n  const lo = x_lo + 1 | 0;\n  return [\n    x_hi + (\n      lo === 0 ? 1 : 0\n    ) | 0,\n    (lo >>> 0)\n  ];\n}\n\nfunction neg(param) {\n  const other_lo = (param[1] ^ -1) + 1 | 0;\n  return [\n    (param[0] ^ -1) + (\n      other_lo === 0 ? 1 : 0\n    ) | 0,\n    (other_lo >>> 0)\n  ];\n}\n\nfunction add_aux(param, y_lo, y_hi) {\n  const x_lo = param[1];\n  const lo = x_lo + y_lo | 0;\n  const overflow = neg_signed(x_lo) && (neg_signed(y_lo) || non_neg_signed(lo)) || neg_signed(y_lo) && non_neg_signed(lo) ? 1 : 0;\n  return [\n    param[0] + y_hi + overflow | 0,\n    (lo >>> 0)\n  ];\n}\n\nfunction add(self, param) {\n  return add_aux(self, param[1], param[0]);\n}\n\nfunction equal_null(x, y) {\n  if (y !== null) {\n    return Caml.i64_eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_undefined(x, y) {\n  if (y !== undefined) {\n    return Caml.i64_eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_nullable(x, y) {\n  if (y == null) {\n    return false;\n  } else {\n    return Caml.i64_eq(x, y);\n  }\n}\n\nfunction sub_aux(x, lo, hi) {\n  const y_lo = ((lo ^ -1) + 1 >>> 0);\n  const y_hi = (hi ^ -1) + (\n    y_lo === 0 ? 1 : 0\n  ) | 0;\n  return add_aux(x, y_lo, y_hi);\n}\n\nfunction sub(self, param) {\n  return sub_aux(self, param[1], param[0]);\n}\n\nfunction lsl_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  const lo = x[1];\n  if (numBits >= 32) {\n    return [\n      (lo << (numBits - 32 | 0)),\n      0\n    ];\n  } else {\n    return [\n      (lo >>> (32 - numBits | 0)) | (x[0] << numBits),\n      ((lo << numBits) >>> 0)\n    ];\n  }\n}\n\nfunction lsr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  const hi = x[0];\n  const offset = numBits - 32 | 0;\n  if (offset === 0) {\n    return [\n      0,\n      (hi >>> 0)\n    ];\n  } else if (offset > 0) {\n    return [\n      0,\n      (hi >>> offset)\n    ];\n  } else {\n    return [\n      (hi >>> numBits),\n      (((hi << (-offset | 0)) | (x[1] >>> numBits)) >>> 0)\n    ];\n  }\n}\n\nfunction asr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  }\n  const hi = x[0];\n  if (numBits < 32) {\n    return [\n      (hi >> numBits),\n      (((hi << (32 - numBits | 0)) | (x[1] >>> numBits)) >>> 0)\n    ];\n  } else {\n    return [\n      hi >= 0 ? 0 : -1,\n      ((hi >> (numBits - 32 | 0)) >>> 0)\n    ];\n  }\n}\n\nfunction is_zero(param) {\n  if (param[0] !== 0) {\n    return false;\n  } else {\n    return param[1] === 0;\n  }\n}\n\nfunction mul(_this, _other) {\n  while (true) {\n    const other = _other;\n    const $$this = _this;\n    let lo;\n    const this_hi = $$this[0];\n    let exit = 0;\n    let exit$1 = 0;\n    let exit$2 = 0;\n    if (this_hi !== 0) {\n      exit$2 = 4;\n    } else {\n      if ($$this[1] === 0) {\n        return zero;\n      }\n      exit$2 = 4;\n    }\n    if (exit$2 === 4) {\n      if (other[0] !== 0) {\n        exit$1 = 3;\n      } else {\n        if (other[1] === 0) {\n          return zero;\n        }\n        exit$1 = 3;\n      }\n    }\n    if (exit$1 === 3) {\n      if (this_hi !== -2147483648 || $$this[1] !== 0) {\n        exit = 2;\n      } else {\n        lo = other[1];\n      }\n    }\n    if (exit === 2) {\n      const other_hi = other[0];\n      const lo$1 = $$this[1];\n      let exit$3 = 0;\n      if (other_hi !== -2147483648 || other[1] !== 0) {\n        exit$3 = 3;\n      } else {\n        lo = lo$1;\n      }\n      if (exit$3 === 3) {\n        const other_lo = other[1];\n        if (this_hi < 0) {\n          if (other_hi >= 0) {\n            return neg(mul(neg($$this), other));\n          }\n          _other = neg(other);\n          _this = neg($$this);\n          continue;\n        }\n        if (other_hi < 0) {\n          return neg(mul($$this, neg(other)));\n        }\n        const a48 = (this_hi >>> 16);\n        const a32 = this_hi & 65535;\n        const a16 = (lo$1 >>> 16);\n        const a00 = lo$1 & 65535;\n        const b48 = (other_hi >>> 16);\n        const b32 = other_hi & 65535;\n        const b16 = (other_lo >>> 16);\n        const b00 = other_lo & 65535;\n        let c48 = 0;\n        let c32 = 0;\n        let c16 = 0;\n        const c00 = a00 * b00;\n        c16 = (c00 >>> 16) + a16 * b00;\n        c32 = (c16 >>> 16);\n        c16 = (c16 & 65535) + a00 * b16;\n        c32 = c32 + (c16 >>> 16) + a32 * b00;\n        c48 = (c32 >>> 16);\n        c32 = (c32 & 65535) + a16 * b16;\n        c48 = c48 + (c32 >>> 16);\n        c32 = (c32 & 65535) + a00 * b32;\n        c48 = c48 + (c32 >>> 16);\n        c32 = c32 & 65535;\n        c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;\n        return [\n          c32 | (c48 << 16),\n          ((c00 & 65535 | ((c16 & 65535) << 16)) >>> 0)\n        ];\n      }\n      \n    }\n    if ((lo & 1) === 0) {\n      return zero;\n    } else {\n      return min_int;\n    }\n  };\n}\n\nfunction xor(param, param$1) {\n  return [\n    param[0] ^ param$1[0],\n    ((param[1] ^ param$1[1]) >>> 0)\n  ];\n}\n\nfunction or_(param, param$1) {\n  return [\n    param[0] | param$1[0],\n    ((param[1] | param$1[1]) >>> 0)\n  ];\n}\n\nfunction and_(param, param$1) {\n  return [\n    param[0] & param$1[0],\n    ((param[1] & param$1[1]) >>> 0)\n  ];\n}\n\nfunction to_float(param) {\n  return param[0] * 0x100000000 + param[1];\n}\n\nfunction of_float(x) {\n  if (isNaN(x) || !isFinite(x)) {\n    return zero;\n  }\n  if (x <= -9.22337203685477581e+18) {\n    return min_int;\n  }\n  if (x + 1 >= 9.22337203685477581e+18) {\n    return max_int;\n  }\n  if (x < 0) {\n    return neg(of_float(- x));\n  }\n  const hi = x / 4294967296 | 0;\n  const lo = x % 4294967296 | 0;\n  return [\n    hi,\n    (lo >>> 0)\n  ];\n}\n\nfunction isSafeInteger(param) {\n  const hi = param[0];\n  const top11Bits = (hi >> 21);\n  if (top11Bits === 0) {\n    return true;\n  } else if (top11Bits === -1) {\n    return !(param[1] === 0 && hi === -2097152);\n  } else {\n    return false;\n  }\n}\n\nfunction to_string(self) {\n  if (isSafeInteger(self)) {\n    return String(to_float(self));\n  }\n  if (self[0] < 0) {\n    if (Caml.i64_eq(self, min_int)) {\n      return \"-9223372036854775808\";\n    } else {\n      return \"-\" + to_string(neg(self));\n    }\n  }\n  const approx_div1 = of_float(Math.floor(to_float(self) / 10));\n  const lo = approx_div1[1];\n  const hi = approx_div1[0];\n  const match = sub_aux(sub_aux(self, (lo << 3), (lo >>> 29) | (hi << 3)), (lo << 1), (lo >>> 31) | (hi << 1));\n  const rem_lo = match[1];\n  const rem_hi = match[0];\n  if (rem_lo === 0 && rem_hi === 0) {\n    return to_string(approx_div1) + \"0\";\n  }\n  if (rem_hi < 0) {\n    const rem_lo$1 = ((rem_lo ^ -1) + 1 >>> 0);\n    const delta = Math.ceil(rem_lo$1 / 10);\n    const remainder = 10 * delta - rem_lo$1;\n    return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);\n  }\n  const delta$1 = Math.floor(rem_lo / 10);\n  const remainder$1 = rem_lo - 10 * delta$1;\n  return to_string(add_aux(approx_div1, delta$1 | 0, 0)) + String(remainder$1 | 0);\n}\n\nfunction div(_self, _other) {\n  while (true) {\n    const other = _other;\n    const self = _self;\n    let exit = 0;\n    if (other[0] !== 0 || other[1] !== 0) {\n      exit = 1;\n    } else {\n      throw new Caml_js_exceptions.MelangeError(\"Division_by_zero\", {\n          MEL_EXN_ID: \"Division_by_zero\"\n        });\n    }\n    if (exit === 1) {\n      const self_hi = self[0];\n      let exit$1 = 0;\n      if (self_hi !== -2147483648) {\n        if (self_hi !== 0) {\n          exit$1 = 2;\n        } else {\n          if (self[1] === 0) {\n            return zero;\n          }\n          exit$1 = 2;\n        }\n      } else if (self[1] !== 0) {\n        exit$1 = 2;\n      } else {\n        if (Caml.i64_eq(other, one) || Caml.i64_eq(other, neg_one)) {\n          return self;\n        }\n        if (Caml.i64_eq(other, min_int)) {\n          return one;\n        }\n        const half_this = asr_(self, 1);\n        const approx = lsl_(div(half_this, other), 1);\n        let exit$2 = 0;\n        if (approx[0] !== 0) {\n          exit$2 = 3;\n        } else {\n          if (approx[1] === 0) {\n            if (other[0] < 0) {\n              return one;\n            } else {\n              return neg(one);\n            }\n          }\n          exit$2 = 3;\n        }\n        if (exit$2 === 3) {\n          const rem = sub(self, mul(other, approx));\n          return add(approx, div(rem, other));\n        }\n        \n      }\n      if (exit$1 === 2) {\n        const other_hi = other[0];\n        let exit$3 = 0;\n        if (other_hi !== -2147483648) {\n          exit$3 = 3;\n        } else {\n          if (other[1] === 0) {\n            return zero;\n          }\n          exit$3 = 3;\n        }\n        if (exit$3 === 3) {\n          if (self_hi < 0) {\n            if (other_hi >= 0) {\n              return neg(div(neg(self), other));\n            }\n            _other = neg(other);\n            _self = neg(self);\n            continue;\n          }\n          if (other_hi < 0) {\n            return neg(div(self, neg(other)));\n          }\n          let res = zero;\n          let rem$1 = self;\n          while (Caml.i64_ge(rem$1, other)) {\n            const b = Math.floor(to_float(rem$1) / to_float(other));\n            let approx$1 = 1 > b ? 1 : b;\n            const log2 = Math.ceil(Math.log(approx$1) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = of_float(approx$1);\n            let approxRem = mul(approxRes, other);\n            while (approxRem[0] < 0 || Caml.i64_gt(approxRem, rem$1)) {\n              approx$1 = approx$1 - delta;\n              approxRes = of_float(approx$1);\n              approxRem = mul(approxRes, other);\n            };\n            if (is_zero(approxRes)) {\n              approxRes = one;\n            }\n            res = add(res, approxRes);\n            rem$1 = sub(rem$1, approxRem);\n          };\n          return res;\n        }\n        \n      }\n      \n    }\n    \n  };\n}\n\nfunction mod_(self, other) {\n  return sub(self, mul(div(self, other), other));\n}\n\nfunction div_mod(self, other) {\n  const quotient = div(self, other);\n  return [\n    quotient,\n    sub(self, mul(quotient, other))\n  ];\n}\n\nfunction compare(self, other) {\n  const y = other[0];\n  const x = self[0];\n  const v = x < y ? -1 : (\n      x === y ? 0 : 1\n    );\n  if (v !== 0) {\n    return v;\n  }\n  const y$1 = other[1];\n  const x$1 = self[1];\n  if (x$1 < y$1) {\n    return -1;\n  } else if (x$1 === y$1) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction of_int32(lo) {\n  return [\n    lo < 0 ? -1 : 0,\n    (lo >>> 0)\n  ];\n}\n\nfunction to_int32(x) {\n  return x[1] | 0;\n}\n\nfunction to_hex(x) {\n  const x_lo = x[1];\n  const x_hi = x[0];\n  const aux = function (v) {\n    return (v >>> 0).toString(16);\n  };\n  if (x_hi === 0 && x_lo === 0) {\n    return \"0\";\n  }\n  if (x_lo === 0) {\n    return aux(x_hi) + \"00000000\";\n  }\n  if (x_hi === 0) {\n    return aux(x_lo);\n  }\n  const lo = aux(x_lo);\n  const pad = 8 - lo.length | 0;\n  if (pad <= 0) {\n    return aux(x_hi) + lo;\n  } else {\n    return aux(x_hi) + (\"0\".repeat(pad) + lo);\n  }\n}\n\nfunction discard_sign(x) {\n  return [\n    2147483647 & x[0],\n    x[1]\n  ];\n}\n\nfunction float_of_bits(x) {\n  return (function(lo,hi){ return (new Float64Array(new Int32Array([lo,hi]).buffer))[0]}\n  )(x[1], x[0]);\n}\n\nfunction bits_of_float(x) {\n  const match = (function(x){return new Int32Array(new Float64Array([x]).buffer)}\n  )(x);\n  return [\n    match[1],\n    (match[0] >>> 0)\n  ];\n}\n\nexport {\n  mk,\n  succ,\n  min_int,\n  max_int,\n  one,\n  zero,\n  neg_one,\n  of_int32,\n  to_int32,\n  add,\n  neg,\n  sub,\n  lsl_,\n  lsr_,\n  asr_,\n  is_zero,\n  mul,\n  xor,\n  or_,\n  and_,\n  equal_null,\n  equal_undefined,\n  equal_nullable,\n  to_float,\n  of_float,\n  div,\n  mod_,\n  compare,\n  float_of_bits,\n  bits_of_float,\n  div_mod,\n  to_hex,\n  discard_sign,\n  to_string,\n}\n/* No side effect */\n", "// Generated by Melange\n\nimport * as Caml_int64 from \"./caml_int64.js\";\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\n\nfunction set(s, i, ch) {\n  if (i < 0 || i >= s.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  s[i] = ch;\n}\n\nfunction get(s, i) {\n  if (i < 0 || i >= s.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  return s[i];\n}\n\nfunction caml_fill_bytes(s, i, l, c) {\n  if (l <= 0) {\n    return;\n  }\n  for (let k = i, k_finish = l + i | 0; k < k_finish; ++k) {\n    s[k] = c;\n  }\n}\n\nfunction caml_create_bytes(len) {\n  if (len < 0) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"String.create\"\n      });\n  }\n  const result = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    result[i] = /* '\\000' */0;\n  }\n  return result;\n}\n\nfunction caml_blit_bytes(s1, i1, s2, i2, len) {\n  if (len <= 0) {\n    return;\n  }\n  if (s1 === s2) {\n    if (i1 < i2) {\n      const range_a = (s1.length - i2 | 0) - 1 | 0;\n      const range_b = len - 1 | 0;\n      const range = range_a > range_b ? range_b : range_a;\n      for (let j = range; j >= 0; --j) {\n        s1[i2 + j | 0] = s1[i1 + j | 0];\n      }\n      return;\n    }\n    if (i1 <= i2) {\n      return;\n    }\n    const range_a$1 = (s1.length - i1 | 0) - 1 | 0;\n    const range_b$1 = len - 1 | 0;\n    const range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;\n    for (let k = 0; k <= range$1; ++k) {\n      s1[i2 + k | 0] = s1[i1 + k | 0];\n    }\n    return;\n  }\n  const off1 = s1.length - i1 | 0;\n  if (len <= off1) {\n    for (let i = 0; i < len; ++i) {\n      s2[i2 + i | 0] = s1[i1 + i | 0];\n    }\n    return;\n  }\n  for (let i$1 = 0; i$1 < off1; ++i$1) {\n    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];\n  }\n  for (let i$2 = off1; i$2 < len; ++i$2) {\n    s2[i2 + i$2 | 0] = /* '\\000' */0;\n  }\n}\n\nfunction bytes_to_string(a) {\n  let i = 0;\n  let len = a.length;\n  let s = \"\";\n  let s_len = len;\n  if (i === 0 && len <= 4096 && len === a.length) {\n    return String.fromCharCode.apply(null, a);\n  }\n  let offset = 0;\n  while (s_len > 0) {\n    const next = s_len < 1024 ? s_len : 1024;\n    const tmp_bytes = new Array(next);\n    for (let k = 0; k < next; ++k) {\n      tmp_bytes[k] = a[k + offset | 0];\n    }\n    s = s + String.fromCharCode.apply(null, tmp_bytes);\n    s_len = s_len - next | 0;\n    offset = offset + next | 0;\n  };\n  return s;\n}\n\nfunction caml_blit_string(s1, i1, s2, i2, len) {\n  if (len <= 0) {\n    return;\n  }\n  const off1 = s1.length - i1 | 0;\n  if (len <= off1) {\n    for (let i = 0; i < len; ++i) {\n      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);\n    }\n    return;\n  }\n  for (let i$1 = 0; i$1 < off1; ++i$1) {\n    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);\n  }\n  for (let i$2 = off1; i$2 < len; ++i$2) {\n    s2[i2 + i$2 | 0] = /* '\\000' */0;\n  }\n}\n\nfunction bytes_of_string(s) {\n  const len = s.length;\n  const res = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    res[i] = s.charCodeAt(i);\n  }\n  return res;\n}\n\nfunction caml_bytes_compare_aux(s1, s2, _off, len, def) {\n  while (true) {\n    const off = _off;\n    if (off >= len) {\n      return def;\n    }\n    const a = s1[off];\n    const b = s2[off];\n    if (a > b) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    _off = off + 1 | 0;\n    continue;\n  };\n}\n\nfunction caml_bytes_compare(s1, s2) {\n  const len1 = s1.length;\n  const len2 = s2.length;\n  if (len1 === len2) {\n    return caml_bytes_compare_aux(s1, s2, 0, len1, 0);\n  } else if (len1 < len2) {\n    return caml_bytes_compare_aux(s1, s2, 0, len1, -1);\n  } else {\n    return caml_bytes_compare_aux(s1, s2, 0, len2, 1);\n  }\n}\n\nfunction caml_bytes_equal(s1, s2) {\n  const len1 = s1.length;\n  const len2 = s2.length;\n  if (len1 === len2) {\n    let _off = 0;\n    while (true) {\n      const off = _off;\n      if (off === len1) {\n        return true;\n      }\n      const a = s1[off];\n      const b = s2[off];\n      if (a !== b) {\n        return false;\n      }\n      _off = off + 1 | 0;\n      continue;\n    };\n  } else {\n    return false;\n  }\n}\n\nfunction caml_bytes_greaterthan(s1, s2) {\n  return caml_bytes_compare(s1, s2) > 0;\n}\n\nfunction caml_bytes_greaterequal(s1, s2) {\n  return caml_bytes_compare(s1, s2) >= 0;\n}\n\nfunction caml_bytes_lessthan(s1, s2) {\n  return caml_bytes_compare(s1, s2) < 0;\n}\n\nfunction caml_bytes_lessequal(s1, s2) {\n  return caml_bytes_compare(s1, s2) <= 0;\n}\n\nfunction bswap16(x) {\n  return ((x & 255) << 8) | ((x & 65280) >>> 8);\n}\n\nfunction bswap32(x) {\n  return ((x & 255) << 24) | ((x & 65280) << 8) | ((x & 16711680) >>> 8) | ((x & -16777216) >>> 24);\n}\n\nfunction bswap64(x) {\n  return Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.and_(x, [\n    0,\n    255\n  ]), 56), Caml_int64.lsl_(Caml_int64.and_(x, [\n    0,\n    65280\n  ]), 40)), Caml_int64.lsl_(Caml_int64.and_(x, [\n    0,\n    16711680\n  ]), 24)), Caml_int64.lsl_(Caml_int64.and_(x, [\n    0,\n    4278190080\n  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [\n    255,\n    0\n  ]), 8)), Caml_int64.lsr_(Caml_int64.and_(x, [\n    65280,\n    0\n  ]), 24)), Caml_int64.lsr_(Caml_int64.and_(x, [\n    16711680,\n    0\n  ]), 40)), Caml_int64.lsr_(Caml_int64.and_(x, [\n    -16777216,\n    0\n  ]), 56));\n}\n\nfunction get16u(str, idx) {\n  const b1 = str[idx];\n  const b2 = str[idx + 1 | 0];\n  return (b2 << 8) | b1;\n}\n\nfunction get16(str, idx) {\n  if (idx < 0 || (idx + 1 | 0) >= str.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  return get16u(str, idx);\n}\n\nfunction get32(str, idx) {\n  if (idx < 0 || (idx + 3 | 0) >= str.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  const b1 = str[idx];\n  const b2 = str[idx + 1 | 0];\n  const b3 = str[idx + 2 | 0];\n  const b4 = str[idx + 3 | 0];\n  return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;\n}\n\nfunction get64(str, idx) {\n  if (idx < 0 || (idx + 7 | 0) >= str.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  const b1 = str[idx];\n  const b2 = str[idx + 1 | 0];\n  const b3 = str[idx + 2 | 0];\n  const b4 = str[idx + 3 | 0];\n  const b5 = str[idx + 4 | 0];\n  const b6 = str[idx + 5 | 0];\n  const b7 = str[idx + 6 | 0];\n  const b8 = str[idx + 7 | 0];\n  return Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.or_(Caml_int64.lsl_(Caml_int64.of_int32(b8), 56), Caml_int64.of_int32(b7)), 48), Caml_int64.of_int32(b6)), 40), Caml_int64.of_int32(b5)), 32), Caml_int64.of_int32(b4)), 24), Caml_int64.of_int32(b3)), 16), Caml_int64.of_int32(b2)), 8), Caml_int64.of_int32(b1));\n}\n\nfunction set16u(b, idx, newval) {\n  const b2 = 255 & (newval >>> 8);\n  const b1 = 255 & newval;\n  b[idx] = b1;\n  b[idx + 1 | 0] = b2;\n}\n\nfunction set16(b, idx, newval) {\n  if (idx < 0 || (idx + 1 | 0) >= b.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  set16u(b, idx, newval);\n}\n\nfunction set32u(str, idx, newval) {\n  const b4 = 255 & (newval >>> 24);\n  const b3 = 255 & (newval >>> 16);\n  const b2 = 255 & (newval >>> 8);\n  const b1 = 255 & newval;\n  str[idx] = b1;\n  str[idx + 1 | 0] = b2;\n  str[idx + 2 | 0] = b3;\n  str[idx + 3 | 0] = b4;\n}\n\nfunction set32(str, idx, newval) {\n  if (idx < 0 || (idx + 3 | 0) >= str.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  set32u(str, idx, newval);\n}\n\nfunction set64u(str, idx, newval) {\n  const x = Caml_int64.lsr_(newval, 56);\n  const b8 = 255 & (x[1] | 0);\n  const x$1 = Caml_int64.lsr_(newval, 48);\n  const b7 = 255 & (x$1[1] | 0);\n  const x$2 = Caml_int64.lsr_(newval, 40);\n  const b6 = 255 & (x$2[1] | 0);\n  const x$3 = Caml_int64.lsr_(newval, 32);\n  const b5 = 255 & (x$3[1] | 0);\n  const x$4 = Caml_int64.lsr_(newval, 24);\n  const b4 = 255 & (x$4[1] | 0);\n  const x$5 = Caml_int64.lsr_(newval, 16);\n  const b3 = 255 & (x$5[1] | 0);\n  const x$6 = Caml_int64.lsr_(newval, 8);\n  const b2 = 255 & (x$6[1] | 0);\n  const b1 = 255 & (newval[1] | 0);\n  str[idx] = b1;\n  str[idx + 1 | 0] = b2;\n  str[idx + 2 | 0] = b3;\n  str[idx + 3 | 0] = b4;\n  str[idx + 4 | 0] = b5;\n  str[idx + 5 | 0] = b6;\n  str[idx + 6 | 0] = b7;\n  str[idx + 7 | 0] = b8;\n}\n\nfunction set64(str, idx, newval) {\n  if (idx < 0 || (idx + 7 | 0) >= str.length) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  set64u(str, idx, newval);\n}\n\nexport {\n  caml_create_bytes,\n  caml_fill_bytes,\n  get,\n  set,\n  bytes_to_string,\n  caml_blit_bytes,\n  caml_blit_string,\n  bytes_of_string,\n  caml_bytes_compare,\n  caml_bytes_greaterthan,\n  caml_bytes_greaterequal,\n  caml_bytes_lessthan,\n  caml_bytes_lessequal,\n  caml_bytes_equal,\n  bswap16,\n  bswap32,\n  bswap64,\n  get16u,\n  get16,\n  get32,\n  get64,\n  set16u,\n  set16,\n  set32u,\n  set32,\n  set64u,\n  set64,\n}\n/* No side effect */\n", "// Generated by Melange\n\n\nconst getGlobalThis = (function(){\n  if (typeof globalThis !== 'undefined') return globalThis;\n\tif (typeof self !== 'undefined') return self;\n\tif (typeof window !== 'undefined') return window;\n\tif (typeof global !== 'undefined') return global;\n\tif (typeof this !== 'undefined') return this;\n\tthrow new Error('Unable to locate global `this`');\n}\n);\n\nconst resolve = (function(s){\n  var myGlobal = getGlobalThis();\n  if (myGlobal[s] === undefined){\n    throw new Error(s + \" not polyfilled by Melange yet\\n\")\n  }\n  return myGlobal[s]\n}\n);\n\nconst register = (function(s,fn){\n  var myGlobal = getGlobalThis();\n  myGlobal[s] = fn\n  return 0\n}\n);\n\nexport {\n  getGlobalThis,\n  resolve,\n  register,\n}\n/* No side effect */\n", "// Generated by Melange\n\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\n\nfunction get(s, i) {\n  if (i >= s.length || i < 0) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"index out of bounds\"\n      });\n  }\n  return s.charCodeAt(i);\n}\n\nfunction make(n, ch) {\n  return String.fromCharCode(ch).repeat(n);\n}\n\nexport {\n  get,\n  make,\n}\n/* No side effect */\n", "// Generated by Melange\n\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\n\nfunction caml_sys_getenv(s) {\n  if (typeof process === \"undefined\" || process.env === undefined) {\n    throw new Caml_js_exceptions.MelangeError(\"Not_found\", {\n        MEL_EXN_ID: \"Not_found\"\n      });\n  }\n  const x = process.env[s];\n  if (x !== undefined) {\n    return x;\n  }\n  throw new Caml_js_exceptions.MelangeError(\"Not_found\", {\n      MEL_EXN_ID: \"Not_found\"\n    });\n}\n\nconst os_type = (function(_){\n  if(typeof process !== 'undefined' && process.platform === 'win32'){\n        return \"Win32\"\n  }\n  else {\n    return \"Unix\"\n  }\n}\n);\n\nfunction caml_sys_time(param) {\n  if (typeof process === \"undefined\" || process.uptime === undefined) {\n    return -1;\n  } else {\n    return process.uptime();\n  }\n}\n\nfunction caml_sys_system_command(_cmd) {\n  return 127;\n}\n\nconst caml_sys_getcwd = (function(param){\n    if (typeof process === \"undefined\" || process.cwd === undefined){\n      return \"/\"\n    }\n    return process.cwd()\n  }\n);\n\nfunction caml_sys_executable_name(param) {\n  if (typeof process === \"undefined\") {\n    return \"\";\n  }\n  const argv = process.argv;\n  if (argv == null) {\n    return \"\";\n  } else {\n    return argv[0];\n  }\n}\n\nfunction caml_sys_argv(param) {\n  if (typeof process === \"undefined\") {\n    return [\"\"];\n  }\n  const argv = process.argv;\n  if (argv == null) {\n    return [\"\"];\n  } else {\n    return argv;\n  }\n}\n\nfunction caml_sys_exit(exit_code) {\n  if (typeof process !== \"undefined\") {\n    return process.exit(exit_code);\n  }\n  \n}\n\nfunction caml_sys_is_directory(_s) {\n  throw new Caml_js_exceptions.MelangeError(\"Failure\", {\n      MEL_EXN_ID: \"Failure\",\n      _1: \"caml_sys_is_directory not implemented\"\n    });\n}\n\nfunction caml_sys_file_exists(_s) {\n  throw new Caml_js_exceptions.MelangeError(\"Failure\", {\n      MEL_EXN_ID: \"Failure\",\n      _1: \"caml_sys_file_exists not implemented\"\n    });\n}\n\nexport {\n  caml_sys_getenv,\n  caml_sys_time,\n  os_type,\n  caml_sys_system_command,\n  caml_sys_getcwd,\n  caml_sys_executable_name,\n  caml_sys_argv,\n  caml_sys_exit,\n  caml_sys_is_directory,\n  caml_sys_file_exists,\n}\n/* No side effect */\n", "// Generated by Melange\n\nimport * as Caml_bytes from \"melange.js/caml_bytes.js\";\nimport * as Caml_exceptions from \"melange.js/caml_exceptions.js\";\nimport * as Caml_external_polyfill from \"melange.js/caml_external_polyfill.js\";\nimport * as Caml_format from \"melange.js/caml_format.js\";\nimport * as Caml_io from \"melange.js/caml_io.js\";\nimport * as Caml_js_exceptions from \"melange.js/caml_js_exceptions.js\";\nimport * as Caml_string from \"melange.js/caml_string.js\";\nimport * as Caml_sys from \"melange.js/caml_sys.js\";\nimport * as CamlinternalFormatBasics from \"./camlinternalFormatBasics.js\";\nimport * as Curry from \"melange.js/curry.js\";\n\nfunction failwith(s) {\n  throw new Caml_js_exceptions.MelangeError(\"Failure\", {\n      MEL_EXN_ID: \"Failure\",\n      _1: s\n    });\n}\n\nfunction invalid_arg(s) {\n  throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n      MEL_EXN_ID: \"Invalid_argument\",\n      _1: s\n    });\n}\n\nconst Exit = /* @__PURE__ */ Caml_exceptions.create(\"Stdlib.Exit\");\n\nconst Failure = \"Failure\";\n\nconst Sys_error = \"Sys_error\";\n\nconst End_of_file = \"End_of_file\";\n\nfunction abs(x) {\n  if (x >= 0) {\n    return x;\n  } else {\n    return -x | 0;\n  }\n}\n\nfunction lnot(x) {\n  return x ^ -1;\n}\n\nconst min_int = -2147483648;\n\nfunction classify_float(x) {\n  if (isFinite(x)) {\n    if (Math.abs(x) >= 2.22507385850720138e-308) {\n      return /* FP_normal */ 0;\n    } else if (x !== 0) {\n      return /* FP_subnormal */ 1;\n    } else {\n      return /* FP_zero */ 2;\n    }\n  } else if (isNaN(x)) {\n    return /* FP_nan */ 4;\n  } else {\n    return /* FP_infinite */ 3;\n  }\n}\n\nfunction char_of_int(n) {\n  if (n < 0 || n > 255) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"char_of_int\"\n      });\n  }\n  return n;\n}\n\nfunction string_of_bool(b) {\n  if (b) {\n    return \"true\";\n  } else {\n    return \"false\";\n  }\n}\n\nfunction bool_of_string(param) {\n  switch (param) {\n    case \"false\" :\n      return false;\n    case \"true\" :\n      return true;\n    default:\n      throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n          MEL_EXN_ID: \"Invalid_argument\",\n          _1: \"bool_of_string\"\n        });\n  }\n}\n\nfunction bool_of_string_opt(param) {\n  switch (param) {\n    case \"false\" :\n      return false;\n    case \"true\" :\n      return true;\n    default:\n      return;\n  }\n}\n\nfunction int_of_string_opt(s) {\n  try {\n    return Caml_format.caml_int_of_string(s);\n  }\n  catch (raw_exn){\n    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\n    if (exn.MEL_EXN_ID === Failure) {\n      return;\n    }\n    throw exn;\n  }\n}\n\nfunction valid_float_lexem(s) {\n  const l = s.length;\n  let _i = 0;\n  while (true) {\n    const i = _i;\n    if (i >= l) {\n      return s + \".\";\n    }\n    const match = Caml_string.get(s, i);\n    if (match >= 48) {\n      if (match >= 58) {\n        return s;\n      }\n      _i = i + 1 | 0;\n      continue;\n    }\n    if (match !== 45) {\n      return s;\n    }\n    _i = i + 1 | 0;\n    continue;\n  };\n}\n\nfunction string_of_float(f) {\n  return valid_float_lexem(Caml_format.caml_format_float(\"%.12g\", f));\n}\n\nfunction float_of_string_opt(s) {\n  try {\n    return Caml_format.caml_float_of_string(s);\n  }\n  catch (raw_exn){\n    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\n    if (exn.MEL_EXN_ID === Failure) {\n      return;\n    }\n    throw exn;\n  }\n}\n\nfunction $at_dps(_dst, _offset, _l1, l2) {\n  while (true) {\n    const dst = _dst;\n    const offset = _offset;\n    const l1 = _l1;\n    if (!l1) {\n      dst[offset] = l2;\n      return;\n    }\n    const match = l1.tl;\n    const h1 = l1.hd;\n    if (!match) {\n      dst[offset] = {\n        hd: h1,\n        tl: l2\n      };\n      return;\n    }\n    const match$1 = match.tl;\n    const h2 = match.hd;\n    if (!match$1) {\n      dst[offset] = {\n        hd: h1,\n        tl: {\n          hd: h2,\n          tl: l2\n        }\n      };\n      return;\n    }\n    const block = {\n      hd: match$1.hd,\n      tl: 24029\n    };\n    dst[offset] = {\n      hd: h1,\n      tl: {\n        hd: h2,\n        tl: block\n      }\n    };\n    _l1 = match$1.tl;\n    _offset = \"tl\";\n    _dst = block;\n    continue;\n  };\n}\n\nfunction $at(l1, l2) {\n  if (!l1) {\n    return l2;\n  }\n  const match = l1.tl;\n  const h1 = l1.hd;\n  if (!match) {\n    return {\n      hd: h1,\n      tl: l2\n    };\n  }\n  const match$1 = match.tl;\n  const h2 = match.hd;\n  if (!match$1) {\n    return {\n      hd: h1,\n      tl: {\n        hd: h2,\n        tl: l2\n      }\n    };\n  }\n  const block = {\n    hd: match$1.hd,\n    tl: 24029\n  };\n  return {\n    hd: h1,\n    tl: {\n      hd: h2,\n      tl: ($at_dps(block, \"tl\", match$1.tl, l2), block)\n    }\n  };\n}\n\nconst stdin = Caml_io.stdin;\n\nconst stdout = Caml_io.stdout;\n\nconst stderr = Caml_io.stderr;\n\nfunction open_out_gen(mode, perm, name) {\n  const c = Caml_external_polyfill.resolve(\"caml_ml_open_descriptor_out\")(Caml_external_polyfill.resolve(\"caml_sys_open\")(name, mode, perm));\n  Caml_external_polyfill.resolve(\"caml_ml_set_channel_name\")(c, name);\n  return c;\n}\n\nfunction open_out(name) {\n  return open_out_gen({\n    hd: /* Open_wronly */ 1,\n    tl: {\n      hd: /* Open_creat */ 3,\n      tl: {\n        hd: /* Open_trunc */ 4,\n        tl: {\n          hd: /* Open_text */ 7,\n          tl: /* [] */ 0\n        }\n      }\n    }\n  }, 438, name);\n}\n\nfunction open_out_bin(name) {\n  return open_out_gen({\n    hd: /* Open_wronly */ 1,\n    tl: {\n      hd: /* Open_creat */ 3,\n      tl: {\n        hd: /* Open_trunc */ 4,\n        tl: {\n          hd: /* Open_binary */ 6,\n          tl: /* [] */ 0\n        }\n      }\n    }\n  }, 438, name);\n}\n\nfunction flush_all(param) {\n  let _param = Caml_io.caml_ml_out_channels_list(undefined);\n  while (true) {\n    const param$1 = _param;\n    if (!param$1) {\n      return;\n    }\n    try {\n      Caml_io.caml_ml_flush(param$1.hd);\n    }\n    catch (raw_exn){\n      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\n      if (exn.MEL_EXN_ID !== Sys_error) {\n        throw exn;\n      }\n      \n    }\n    _param = param$1.tl;\n    continue;\n  };\n}\n\nfunction output_bytes(oc, s) {\n  Caml_external_polyfill.resolve(\"caml_ml_output_bytes\")(oc, s, 0, s.length);\n}\n\nfunction output_string(oc, s) {\n  Caml_io.caml_ml_output(oc, s, 0, s.length);\n}\n\nfunction output(oc, s, ofs, len) {\n  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"output\"\n      });\n  }\n  Caml_external_polyfill.resolve(\"caml_ml_output_bytes\")(oc, s, ofs, len);\n}\n\nfunction output_substring(oc, s, ofs, len) {\n  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"output_substring\"\n      });\n  }\n  Caml_io.caml_ml_output(oc, s, ofs, len);\n}\n\nfunction output_value(chan, v) {\n  Caml_external_polyfill.resolve(\"caml_output_value\")(chan, v, /* [] */ 0);\n}\n\nfunction close_out(oc) {\n  Caml_io.caml_ml_flush(oc);\n  Caml_external_polyfill.resolve(\"caml_ml_close_channel\")(oc);\n}\n\nfunction close_out_noerr(oc) {\n  try {\n    Caml_io.caml_ml_flush(oc);\n  }\n  catch (exn){\n    \n  }\n  try {\n    return Caml_external_polyfill.resolve(\"caml_ml_close_channel\")(oc);\n  }\n  catch (exn$1){\n    return;\n  }\n}\n\nfunction open_in_gen(mode, perm, name) {\n  const c = Caml_external_polyfill.resolve(\"caml_ml_open_descriptor_in\")(Caml_external_polyfill.resolve(\"caml_sys_open\")(name, mode, perm));\n  Caml_external_polyfill.resolve(\"caml_ml_set_channel_name\")(c, name);\n  return c;\n}\n\nfunction open_in(name) {\n  return open_in_gen({\n    hd: /* Open_rdonly */ 0,\n    tl: {\n      hd: /* Open_text */ 7,\n      tl: /* [] */ 0\n    }\n  }, 0, name);\n}\n\nfunction open_in_bin(name) {\n  return open_in_gen({\n    hd: /* Open_rdonly */ 0,\n    tl: {\n      hd: /* Open_binary */ 6,\n      tl: /* [] */ 0\n    }\n  }, 0, name);\n}\n\nfunction input(ic, s, ofs, len) {\n  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"input\"\n      });\n  }\n  return Caml_external_polyfill.resolve(\"caml_ml_input\")(ic, s, ofs, len);\n}\n\nfunction unsafe_really_input(ic, s, _ofs, _len) {\n  while (true) {\n    const len = _len;\n    const ofs = _ofs;\n    if (len <= 0) {\n      return;\n    }\n    const r = Caml_external_polyfill.resolve(\"caml_ml_input\")(ic, s, ofs, len);\n    if (r === 0) {\n      throw new Caml_js_exceptions.MelangeError(End_of_file, {\n          MEL_EXN_ID: End_of_file\n        });\n    }\n    _len = len - r | 0;\n    _ofs = ofs + r | 0;\n    continue;\n  };\n}\n\nfunction really_input(ic, s, ofs, len) {\n  if (ofs < 0 || len < 0 || ofs > (s.length - len | 0)) {\n    throw new Caml_js_exceptions.MelangeError(\"Invalid_argument\", {\n        MEL_EXN_ID: \"Invalid_argument\",\n        _1: \"really_input\"\n      });\n  }\n  unsafe_really_input(ic, s, ofs, len);\n}\n\nfunction really_input_string(ic, len) {\n  const s = Caml_bytes.caml_create_bytes(len);\n  really_input(ic, s, 0, len);\n  return Caml_bytes.bytes_to_string(s);\n}\n\nfunction input_line(chan) {\n  const build_result = function (buf, _pos, _param) {\n    while (true) {\n      const param = _param;\n      const pos = _pos;\n      if (!param) {\n        return buf;\n      }\n      const hd = param.hd;\n      const len = hd.length;\n      Caml_bytes.caml_blit_bytes(hd, 0, buf, pos - len | 0, len);\n      _param = param.tl;\n      _pos = pos - len | 0;\n      continue;\n    };\n  };\n  const scan = function (_accu, _len) {\n    while (true) {\n      const len = _len;\n      const accu = _accu;\n      const n = Caml_external_polyfill.resolve(\"caml_ml_input_scan_line\")(chan);\n      if (n === 0) {\n        if (accu) {\n          return build_result(Caml_bytes.caml_create_bytes(len), len, accu);\n        }\n        throw new Caml_js_exceptions.MelangeError(End_of_file, {\n            MEL_EXN_ID: End_of_file\n          });\n      }\n      if (n > 0) {\n        const res = Caml_bytes.caml_create_bytes(n - 1 | 0);\n        Caml_external_polyfill.resolve(\"caml_ml_input\")(chan, res, 0, n - 1 | 0);\n        Caml_external_polyfill.resolve(\"caml_ml_input_char\")(chan);\n        if (!accu) {\n          return res;\n        }\n        const len$1 = (len + n | 0) - 1 | 0;\n        return build_result(Caml_bytes.caml_create_bytes(len$1), len$1, {\n          hd: res,\n          tl: accu\n        });\n      }\n      const beg = Caml_bytes.caml_create_bytes(-n | 0);\n      Caml_external_polyfill.resolve(\"caml_ml_input\")(chan, beg, 0, -n | 0);\n      _len = len - n | 0;\n      _accu = {\n        hd: beg,\n        tl: accu\n      };\n      continue;\n    };\n  };\n  return Caml_bytes.bytes_to_string(scan(/* [] */ 0, 0));\n}\n\nfunction close_in_noerr(ic) {\n  try {\n    return Caml_external_polyfill.resolve(\"caml_ml_close_channel\")(ic);\n  }\n  catch (exn){\n    return;\n  }\n}\n\nfunction print_char(c) {\n  Caml_io.caml_ml_output_char(stdout, c);\n}\n\nfunction print_string(s) {\n  output_string(stdout, s);\n}\n\nfunction print_bytes(s) {\n  output_bytes(stdout, s);\n}\n\nfunction print_int(i) {\n  output_string(stdout, String(i));\n}\n\nfunction print_float(f) {\n  output_string(stdout, valid_float_lexem(Caml_format.caml_format_float(\"%.12g\", f)));\n}\n\nfunction print_newline(param) {\n  Caml_io.caml_ml_output_char(stdout, /* '\\n' */10);\n  Caml_io.caml_ml_flush(stdout);\n}\n\nfunction prerr_char(c) {\n  Caml_io.caml_ml_output_char(stderr, c);\n}\n\nfunction prerr_string(s) {\n  output_string(stderr, s);\n}\n\nfunction prerr_bytes(s) {\n  output_bytes(stderr, s);\n}\n\nfunction prerr_int(i) {\n  output_string(stderr, String(i));\n}\n\nfunction prerr_float(f) {\n  output_string(stderr, valid_float_lexem(Caml_format.caml_format_float(\"%.12g\", f)));\n}\n\nfunction prerr_newline(param) {\n  Caml_io.caml_ml_output_char(stderr, /* '\\n' */10);\n  Caml_io.caml_ml_flush(stderr);\n}\n\nfunction read_line(param) {\n  Caml_io.caml_ml_flush(stdout);\n  return input_line(stdin);\n}\n\nfunction read_int(param) {\n  return Caml_format.caml_int_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));\n}\n\nfunction read_int_opt(param) {\n  return int_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));\n}\n\nfunction read_float(param) {\n  return Caml_format.caml_float_of_string((Caml_io.caml_ml_flush(stdout), input_line(stdin)));\n}\n\nfunction read_float_opt(param) {\n  return float_of_string_opt((Caml_io.caml_ml_flush(stdout), input_line(stdin)));\n}\n\nfunction string_of_format(param) {\n  return param._1;\n}\n\nfunction $caret$caret(param, param$1) {\n  return {\n    TAG: /* Format */ 0,\n    _0: CamlinternalFormatBasics.concat_fmt(param._0, param$1._0),\n    _1: param._1 + (\"%,\" + param$1._1)\n  };\n}\n\nconst exit_function = {\n  contents: flush_all\n};\n\nfunction at_exit(f) {\n  const f_yet_to_run = {\n    contents: true\n  };\n  const old_exit = exit_function.contents;\n  const new_exit = function (param) {\n    if (!f_yet_to_run.contents) {\n      f_yet_to_run.contents = false;\n      Curry._1(f, undefined);\n    }\n    Curry._1(old_exit, undefined);\n  };\n  exit_function.contents = new_exit;\n}\n\nconst do_domain_local_at_exit = {\n  contents: (function (param) {\n    \n  })\n};\n\nfunction do_at_exit(param) {\n  Curry._1(do_domain_local_at_exit.contents, undefined);\n  Curry._1(exit_function.contents, undefined);\n}\n\nfunction exit(retcode) {\n  do_at_exit(undefined);\n  return Caml_sys.caml_sys_exit(retcode);\n}\n\nconst Match_failure = \"Match_failure\";\n\nconst Assert_failure = \"Assert_failure\";\n\nconst Invalid_argument = \"Invalid_argument\";\n\nconst Not_found = \"Not_found\";\n\nconst Out_of_memory = \"Out_of_memory\";\n\nconst Stack_overflow = \"Stack_overflow\";\n\nconst Division_by_zero = \"Division_by_zero\";\n\nconst Sys_blocked_io = \"Sys_blocked_io\";\n\nconst Undefined_recursive_module = \"Undefined_recursive_module\";\n\nconst max_int = 2147483647;\n\nconst infinity = Infinity;\n\nconst neg_infinity = -Infinity;\n\nconst max_float = 1.79769313486231571e+308;\n\nconst min_float = 2.22507385850720138e-308;\n\nconst epsilon_float = 2.22044604925031308e-16;\n\nconst flush = Caml_io.caml_ml_flush;\n\nconst output_char = Caml_io.caml_ml_output_char;\n\nconst output_byte = Caml_io.caml_ml_output_char;\n\nfunction output_binary_int(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_output_int\")(prim0, prim1);\n}\n\nfunction seek_out(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_seek_out\")(prim0, prim1);\n}\n\nfunction pos_out(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_pos_out\")(prim);\n}\n\nfunction out_channel_length(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_channel_size\")(prim);\n}\n\nfunction set_binary_mode_out(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_set_binary_mode\")(prim0, prim1);\n}\n\nfunction input_char(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_input_char\")(prim);\n}\n\nfunction input_byte(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_input_char\")(prim);\n}\n\nfunction input_binary_int(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_input_int\")(prim);\n}\n\nfunction input_value(prim) {\n  return Caml_external_polyfill.resolve(\"caml_input_value\")(prim);\n}\n\nfunction seek_in(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_seek_in\")(prim0, prim1);\n}\n\nfunction pos_in(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_pos_in\")(prim);\n}\n\nfunction in_channel_length(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_channel_size\")(prim);\n}\n\nfunction close_in(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_close_channel\")(prim);\n}\n\nfunction set_binary_mode_in(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_set_binary_mode\")(prim0, prim1);\n}\n\nfunction LargeFile_seek_out(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_seek_out_64\")(prim0, prim1);\n}\n\nfunction LargeFile_pos_out(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_pos_out_64\")(prim);\n}\n\nfunction LargeFile_out_channel_length(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_channel_size_64\")(prim);\n}\n\nfunction LargeFile_seek_in(prim0, prim1) {\n  return Caml_external_polyfill.resolve(\"caml_ml_seek_in_64\")(prim0, prim1);\n}\n\nfunction LargeFile_pos_in(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_pos_in_64\")(prim);\n}\n\nfunction LargeFile_in_channel_length(prim) {\n  return Caml_external_polyfill.resolve(\"caml_ml_channel_size_64\")(prim);\n}\n\nconst LargeFile = {\n  seek_out: LargeFile_seek_out,\n  pos_out: LargeFile_pos_out,\n  out_channel_length: LargeFile_out_channel_length,\n  seek_in: LargeFile_seek_in,\n  pos_in: LargeFile_pos_in,\n  in_channel_length: LargeFile_in_channel_length\n};\n\nexport {\n  invalid_arg,\n  failwith,\n  Exit,\n  Match_failure,\n  Assert_failure,\n  Invalid_argument,\n  Failure,\n  Not_found,\n  Out_of_memory,\n  Stack_overflow,\n  Sys_error,\n  End_of_file,\n  Division_by_zero,\n  Sys_blocked_io,\n  Undefined_recursive_module,\n  abs,\n  max_int,\n  min_int,\n  lnot,\n  infinity,\n  neg_infinity,\n  max_float,\n  min_float,\n  epsilon_float,\n  classify_float,\n  char_of_int,\n  string_of_bool,\n  bool_of_string_opt,\n  bool_of_string,\n  int_of_string_opt,\n  string_of_float,\n  float_of_string_opt,\n  $at,\n  stdin,\n  stdout,\n  stderr,\n  print_char,\n  print_string,\n  print_bytes,\n  print_int,\n  print_float,\n  print_newline,\n  prerr_char,\n  prerr_string,\n  prerr_bytes,\n  prerr_int,\n  prerr_float,\n  prerr_newline,\n  read_line,\n  read_int_opt,\n  read_int,\n  read_float_opt,\n  read_float,\n  open_out,\n  open_out_bin,\n  open_out_gen,\n  flush,\n  flush_all,\n  output_char,\n  output_string,\n  output_bytes,\n  output,\n  output_substring,\n  output_byte,\n  output_binary_int,\n  output_value,\n  seek_out,\n  pos_out,\n  out_channel_length,\n  close_out,\n  close_out_noerr,\n  set_binary_mode_out,\n  open_in,\n  open_in_bin,\n  open_in_gen,\n  input_char,\n  input_line,\n  input,\n  really_input,\n  really_input_string,\n  input_byte,\n  input_binary_int,\n  input_value,\n  seek_in,\n  pos_in,\n  in_channel_length,\n  close_in,\n  close_in_noerr,\n  set_binary_mode_in,\n  LargeFile,\n  string_of_format,\n  $caret$caret,\n  exit,\n  at_exit,\n  valid_float_lexem,\n  unsafe_really_input,\n  do_at_exit,\n  do_domain_local_at_exit,\n}\n/* No side effect */\n"],
  "mappings": "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",
  "names": ["get"]
}
