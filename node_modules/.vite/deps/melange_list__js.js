import {
  caml_equal
} from "./chunk-Y6CS5PWF.js";
import {
  $at,
  Not_found
} from "./chunk-U34IA575.js";
import {
  some,
  valFromOption
} from "./chunk-IW5MXQOG.js";
import {
  MelangeError,
  _1,
  _2,
  _3
} from "./chunk-3PFLCYLG.js";
import "./chunk-5WRI5ZAA.js";

// _build/default/src/output/node_modules/melange/list.js
function length(l) {
  let _len = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const len = _len;
    if (!param) {
      return len;
    }
    _param = param.tl;
    _len = len + 1 | 0;
    continue;
  }
  ;
}
function cons(a, l) {
  return {
    hd: a,
    tl: l
  };
}
function hd(param) {
  if (param) {
    return param.hd;
  }
  throw new MelangeError("Failure", {
    MEL_EXN_ID: "Failure",
    _1: "hd"
  });
}
function tl(param) {
  if (param) {
    return param.tl;
  }
  throw new MelangeError("Failure", {
    MEL_EXN_ID: "Failure",
    _1: "tl"
  });
}
function nth(l, n) {
  if (n < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.nth"
    });
  }
  let _l = l;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const l$1 = _l;
    if (l$1) {
      if (n$1 === 0) {
        return l$1.hd;
      }
      _n = n$1 - 1 | 0;
      _l = l$1.tl;
      continue;
    }
    throw new MelangeError("Failure", {
      MEL_EXN_ID: "Failure",
      _1: "nth"
    });
  }
  ;
}
function nth_opt(l, n) {
  if (n < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.nth"
    });
  }
  let _l = l;
  let _n = n;
  while (true) {
    const n$1 = _n;
    const l$1 = _l;
    if (!l$1) {
      return;
    }
    if (n$1 === 0) {
      return some(l$1.hd);
    }
    _n = n$1 - 1 | 0;
    _l = l$1.tl;
    continue;
  }
  ;
}
function rev_append(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      return l2;
    }
    _l2 = {
      hd: l1.hd,
      tl: l2
    };
    _l1 = l1.tl;
    continue;
  }
  ;
}
function rev(l) {
  return rev_append(
    l,
    /* [] */
    0
  );
}
function init_dps(_dst, _offset, _i, last, f) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    if (i > last) {
      dst[offset] = /* [] */
      0;
      return;
    }
    if (i === last) {
      dst[offset] = {
        hd: _1(f, i),
        tl: (
          /* [] */
          0
        )
      };
      return;
    }
    const r1 = _1(f, i);
    const r2 = _1(f, i + 1 | 0);
    const block = {
      hd: r2,
      tl: 24029
    };
    dst[offset] = {
      hd: r1,
      tl: block
    };
    _i = i + 2 | 0;
    _offset = "tl";
    _dst = block;
    continue;
  }
  ;
}
function init(len, f) {
  if (len < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.init"
    });
  }
  let i = 0;
  let last = len - 1 | 0;
  if (i > last) {
    return (
      /* [] */
      0
    );
  }
  if (i === last) {
    return {
      hd: _1(f, i),
      tl: (
        /* [] */
        0
      )
    };
  }
  const r1 = _1(f, i);
  const r2 = _1(f, i + 1 | 0);
  const block = {
    hd: r2,
    tl: 24029
  };
  return {
    hd: r1,
    tl: (init_dps(block, "tl", i + 2 | 0, last, f), block)
  };
}
function flatten(param) {
  if (param) {
    return $at(param.hd, flatten(param.tl));
  } else {
    return (
      /* [] */
      0
    );
  }
}
function map_dps(_dst, _offset, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const match = param.tl;
    const a1 = param.hd;
    if (match) {
      const r1 = _1(f, a1);
      const r2 = _1(f, match.hd);
      const block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _offset = "tl";
      _dst = block;
      continue;
    }
    const r1$1 = _1(f, a1);
    dst[offset] = {
      hd: r1$1,
      tl: (
        /* [] */
        0
      )
    };
    return;
  }
  ;
}
function map(f, param) {
  if (!param) {
    return (
      /* [] */
      0
    );
  }
  const match = param.tl;
  const a1 = param.hd;
  if (match) {
    const r1 = _1(f, a1);
    const r2 = _1(f, match.hd);
    const block = {
      hd: r2,
      tl: 24029
    };
    return {
      hd: r1,
      tl: (map_dps(block, "tl", f, match.tl), block)
    };
  }
  const r1$1 = _1(f, a1);
  return {
    hd: r1$1,
    tl: (
      /* [] */
      0
    )
  };
}
function mapi_dps(_dst, _offset, _i, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const match = param.tl;
    const a1 = param.hd;
    if (match) {
      const r1 = _2(f, i, a1);
      const r2 = _2(f, i + 1 | 0, match.hd);
      const block = {
        hd: r2,
        tl: 24029
      };
      dst[offset] = {
        hd: r1,
        tl: block
      };
      _param = match.tl;
      _i = i + 2 | 0;
      _offset = "tl";
      _dst = block;
      continue;
    }
    const r1$1 = _2(f, i, a1);
    dst[offset] = {
      hd: r1$1,
      tl: (
        /* [] */
        0
      )
    };
    return;
  }
  ;
}
function mapi(f, l) {
  let i = 0;
  if (!l) {
    return (
      /* [] */
      0
    );
  }
  const match = l.tl;
  const a1 = l.hd;
  if (match) {
    const r1 = _2(f, i, a1);
    const r2 = _2(f, i + 1 | 0, match.hd);
    const block = {
      hd: r2,
      tl: 24029
    };
    return {
      hd: r1,
      tl: (mapi_dps(block, "tl", i + 2 | 0, f, match.tl), block)
    };
  }
  const r1$1 = _2(f, i, a1);
  return {
    hd: r1$1,
    tl: (
      /* [] */
      0
    )
  };
}
function rev_map(f, l) {
  let _accu = (
    /* [] */
    0
  );
  let _param = l;
  while (true) {
    const param = _param;
    const accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = {
      hd: _1(f, param.hd),
      tl: accu
    };
    continue;
  }
  ;
}
function iter(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    _1(f, param.hd);
    _param = param.tl;
    continue;
  }
  ;
}
function iteri(f, l) {
  let _i = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return;
    }
    _2(f, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function fold_left(f, _accu, _l) {
  while (true) {
    const l = _l;
    const accu = _accu;
    if (!l) {
      return accu;
    }
    _l = l.tl;
    _accu = _2(f, accu, l.hd);
    continue;
  }
  ;
}
function fold_right(f, l, accu) {
  if (l) {
    return _2(f, l.hd, fold_right(f, l.tl, accu));
  } else {
    return accu;
  }
}
function map2_dps(_dst, _offset, f, _l1, _l2) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const l1 = _l1;
    const l2 = _l2;
    if (l1) {
      const match = l1.tl;
      const a1 = l1.hd;
      if (match) {
        if (l2) {
          const match$1 = l2.tl;
          if (match$1) {
            const r1 = _2(f, a1, l2.hd);
            const r2 = _2(f, match.hd, match$1.hd);
            const block = {
              hd: r2,
              tl: 24029
            };
            dst[offset] = {
              hd: r1,
              tl: block
            };
            _l2 = match$1.tl;
            _l1 = match.tl;
            _offset = "tl";
            _dst = block;
            continue;
          }
          throw new MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2"
          });
        }
        throw new MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2"
        });
      }
      if (l2) {
        if (l2.tl) {
          throw new MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "List.map2"
          });
        }
        const r1$1 = _2(f, a1, l2.hd);
        dst[offset] = {
          hd: r1$1,
          tl: (
            /* [] */
            0
          )
        };
        return;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2"
      });
    }
    if (l2) {
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2"
      });
    }
    dst[offset] = /* [] */
    0;
    return;
  }
  ;
}
function map2(f, l1, l2) {
  if (l1) {
    const match = l1.tl;
    const a1 = l1.hd;
    if (match) {
      if (l2) {
        const match$1 = l2.tl;
        if (match$1) {
          const r1 = _2(f, a1, l2.hd);
          const r2 = _2(f, match.hd, match$1.hd);
          const block = {
            hd: r2,
            tl: 24029
          };
          return {
            hd: r1,
            tl: (map2_dps(block, "tl", f, match.tl, match$1.tl), block)
          };
        }
        throw new MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2"
        });
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.map2"
      });
    }
    if (l2) {
      if (l2.tl) {
        throw new MelangeError("Invalid_argument", {
          MEL_EXN_ID: "Invalid_argument",
          _1: "List.map2"
        });
      }
      const r1$1 = _2(f, a1, l2.hd);
      return {
        hd: r1$1,
        tl: (
          /* [] */
          0
        )
      };
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.map2"
    });
  }
  if (!l2) {
    return (
      /* [] */
      0
    );
  }
  throw new MelangeError("Invalid_argument", {
    MEL_EXN_ID: "Invalid_argument",
    _1: "List.map2"
  });
}
function rev_map2(f, l1, l2) {
  let _accu = (
    /* [] */
    0
  );
  let _l1 = l1;
  let _l2 = l2;
  while (true) {
    const l2$1 = _l2;
    const l1$1 = _l1;
    const accu = _accu;
    if (l1$1) {
      if (l2$1) {
        _l2 = l2$1.tl;
        _l1 = l1$1.tl;
        _accu = {
          hd: _2(f, l1$1.hd, l2$1.hd),
          tl: accu
        };
        continue;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.rev_map2"
      });
    }
    if (l2$1) {
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.rev_map2"
      });
    }
    return accu;
  }
  ;
}
function iter2(f, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        _2(f, l1.hd, l2.hd);
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.iter2"
      });
    }
    if (!l2) {
      return;
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.iter2"
    });
  }
  ;
}
function fold_left2(f, _accu, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    const accu = _accu;
    if (l1) {
      if (l2) {
        _l2 = l2.tl;
        _l1 = l1.tl;
        _accu = _3(f, accu, l1.hd, l2.hd);
        continue;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.fold_left2"
      });
    }
    if (l2) {
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.fold_left2"
      });
    }
    return accu;
  }
  ;
}
function fold_right2(f, l1, l2, accu) {
  if (l1) {
    if (l2) {
      return _3(f, l1.hd, l2.hd, fold_right2(f, l1.tl, l2.tl, accu));
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.fold_right2"
    });
  }
  if (l2) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.fold_right2"
    });
  }
  return accu;
}
function for_all(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return true;
    }
    if (!_1(p, param.hd)) {
      return false;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function exists(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (_1(p, param.hd)) {
      return true;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function for_all2(p, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        if (!_2(p, l1.hd, l2.hd)) {
          return false;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.for_all2"
      });
    }
    if (!l2) {
      return true;
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.for_all2"
    });
  }
  ;
}
function exists2(p, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (l1) {
      if (l2) {
        if (_2(p, l1.hd, l2.hd)) {
          return true;
        }
        _l2 = l2.tl;
        _l1 = l1.tl;
        continue;
      }
      throw new MelangeError("Invalid_argument", {
        MEL_EXN_ID: "Invalid_argument",
        _1: "List.exists2"
      });
    }
    if (!l2) {
      return false;
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.exists2"
    });
  }
  ;
}
function mem(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (caml_equal(param.hd, x)) {
      return true;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function memq(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (param.hd === x) {
      return true;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function assoc(x, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      if (caml_equal(match[0], x)) {
        return match[1];
      }
      _param = param.tl;
      continue;
    }
    throw new MelangeError(Not_found, {
      MEL_EXN_ID: Not_found
    });
  }
  ;
}
function assoc_opt(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const match = param.hd;
    if (caml_equal(match[0], x)) {
      return some(match[1]);
    }
    _param = param.tl;
    continue;
  }
  ;
}
function assq(x, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const match = param.hd;
      if (match[0] === x) {
        return match[1];
      }
      _param = param.tl;
      continue;
    }
    throw new MelangeError(Not_found, {
      MEL_EXN_ID: Not_found
    });
  }
  ;
}
function assq_opt(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const match = param.hd;
    if (match[0] === x) {
      return some(match[1]);
    }
    _param = param.tl;
    continue;
  }
  ;
}
function mem_assoc(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (caml_equal(param.hd[0], x)) {
      return true;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function mem_assq(x, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return false;
    }
    if (param.hd[0] === x) {
      return true;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function remove_assoc(x, param) {
  if (!param) {
    return (
      /* [] */
      0
    );
  }
  const l = param.tl;
  const pair = param.hd;
  if (caml_equal(pair[0], x)) {
    return l;
  } else {
    return {
      hd: pair,
      tl: remove_assoc(x, l)
    };
  }
}
function remove_assq(x, param) {
  if (!param) {
    return (
      /* [] */
      0
    );
  }
  const l = param.tl;
  const pair = param.hd;
  if (pair[0] === x) {
    return l;
  } else {
    return {
      hd: pair,
      tl: remove_assq(x, l)
    };
  }
}
function find(p, _param) {
  while (true) {
    const param = _param;
    if (param) {
      const x = param.hd;
      if (_1(p, x)) {
        return x;
      }
      _param = param.tl;
      continue;
    }
    throw new MelangeError(Not_found, {
      MEL_EXN_ID: Not_found
    });
  }
  ;
}
function find_opt(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const x = param.hd;
    if (_1(p, x)) {
      return some(x);
    }
    _param = param.tl;
    continue;
  }
  ;
}
function find_index(p) {
  return function(param) {
    let _i = 0;
    let _param = param;
    while (true) {
      const param$1 = _param;
      const i = _i;
      if (!param$1) {
        return;
      }
      if (_1(p, param$1.hd)) {
        return i;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue;
    }
    ;
  };
}
function find_map(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return;
    }
    const result = _1(f, param.hd);
    if (result !== void 0) {
      return result;
    }
    _param = param.tl;
    continue;
  }
  ;
}
function find_mapi(f) {
  return function(param) {
    let _i = 0;
    let _param = param;
    while (true) {
      const param$1 = _param;
      const i = _i;
      if (!param$1) {
        return;
      }
      const result = _2(f, i, param$1.hd);
      if (result !== void 0) {
        return result;
      }
      _param = param$1.tl;
      _i = i + 1 | 0;
      continue;
    }
    ;
  };
}
function find_all(p, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return (
        /* [] */
        0
      );
    }
    const l = param.tl;
    const x = param.hd;
    if (_1(p, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      find_all_dps(block, "tl", p, l);
      return block;
    }
    _param = l;
    continue;
  }
  ;
}
function find_all_dps(_dst, _offset, p, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const l = param.tl;
    const x = param.hd;
    if (_1(p, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    continue;
  }
  ;
}
function filteri_dps(_dst, _offset, p, _i, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const i = _i;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const l = param.tl;
    const x = param.hd;
    const i$p = i + 1 | 0;
    if (_2(p, i, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _i = i$p;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    _i = i$p;
    continue;
  }
  ;
}
function filteri(p, l) {
  let _i = 0;
  let _param = l;
  while (true) {
    const param = _param;
    const i = _i;
    if (!param) {
      return (
        /* [] */
        0
      );
    }
    const l$1 = param.tl;
    const x = param.hd;
    const i$p = i + 1 | 0;
    if (_2(p, i, x)) {
      const block = {
        hd: x,
        tl: 24029
      };
      filteri_dps(block, "tl", p, i$p, l$1);
      return block;
    }
    _param = l$1;
    _i = i$p;
    continue;
  }
  ;
}
function filter_map(f, _param) {
  while (true) {
    const param = _param;
    if (!param) {
      return (
        /* [] */
        0
      );
    }
    const l = param.tl;
    const v = _1(f, param.hd);
    if (v !== void 0) {
      const block = {
        hd: valFromOption(v),
        tl: 24029
      };
      filter_map_dps(block, "tl", f, l);
      return block;
    }
    _param = l;
    continue;
  }
  ;
}
function filter_map_dps(_dst, _offset, f, _param) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const param = _param;
    if (!param) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const l = param.tl;
    const v = _1(f, param.hd);
    if (v !== void 0) {
      const block = {
        hd: valFromOption(v),
        tl: 24029
      };
      dst[offset] = block;
      _param = l;
      _offset = "tl";
      _dst = block;
      continue;
    }
    _param = l;
    continue;
  }
  ;
}
function concat_map(f, param) {
  if (param) {
    let ys = _1(f, param.hd);
    let xs = param.tl;
    if (!ys) {
      return concat_map(f, xs);
    }
    const block = {
      hd: ys.hd,
      tl: 24029
    };
    prepend_concat_map_dps(block, "tl", ys.tl, f, xs);
    return block;
  } else {
    return (
      /* [] */
      0
    );
  }
}
function prepend_concat_map_dps(_dst, _offset, _ys, f, xs) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const ys = _ys;
    if (!ys) {
      if (xs) {
        return prepend_concat_map_dps(dst, offset, _1(f, xs.hd), f, xs.tl);
      } else {
        dst[offset] = /* [] */
        0;
        return;
      }
    }
    const block = {
      hd: ys.hd,
      tl: 24029
    };
    dst[offset] = block;
    _ys = ys.tl;
    _offset = "tl";
    _dst = block;
    continue;
  }
  ;
}
function take(n, l) {
  const aux_dps = function(_dst, _offset, _n, _l) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const n2 = _n;
      const l2 = _l;
      if (n2 === 0) {
        dst[offset] = /* [] */
        0;
        return;
      }
      if (!l2) {
        dst[offset] = /* [] */
        0;
        return;
      }
      const block2 = {
        hd: l2.hd,
        tl: 24029
      };
      dst[offset] = block2;
      _l = l2.tl;
      _n = n2 - 1 | 0;
      _offset = "tl";
      _dst = block2;
      continue;
    }
    ;
  };
  if (n < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.take"
    });
  }
  if (n === 0) {
    return (
      /* [] */
      0
    );
  }
  if (!l) {
    return (
      /* [] */
      0
    );
  }
  const block = {
    hd: l.hd,
    tl: 24029
  };
  aux_dps(block, "tl", n - 1 | 0, l.tl);
  return block;
}
function drop(n, l) {
  if (n < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.drop"
    });
  }
  let _i = 0;
  let _rest = l;
  while (true) {
    const rest = _rest;
    const i = _i;
    if (!rest) {
      return rest;
    }
    if (i >= n) {
      return rest;
    }
    _rest = rest.tl;
    _i = i + 1 | 0;
    continue;
  }
  ;
}
function take_while(p, l) {
  const aux_dps = function(_dst, _offset, __rest) {
    while (true) {
      const dst = _dst;
      const offset = _offset;
      const _rest = __rest;
      if (!_rest) {
        dst[offset] = /* [] */
        0;
        return;
      }
      const x2 = _rest.hd;
      if (!_1(p, x2)) {
        dst[offset] = /* [] */
        0;
        return;
      }
      const block2 = {
        hd: x2,
        tl: 24029
      };
      dst[offset] = block2;
      __rest = _rest.tl;
      _offset = "tl";
      _dst = block2;
      continue;
    }
    ;
  };
  if (!l) {
    return (
      /* [] */
      0
    );
  }
  const x = l.hd;
  if (!_1(p, x)) {
    return (
      /* [] */
      0
    );
  }
  const block = {
    hd: x,
    tl: 24029
  };
  aux_dps(block, "tl", l.tl);
  return block;
}
function drop_while(p, _rest) {
  while (true) {
    const rest = _rest;
    if (!rest) {
      return rest;
    }
    if (!_1(p, rest.hd)) {
      return rest;
    }
    _rest = rest.tl;
    continue;
  }
  ;
}
function fold_left_map(f, accu, l) {
  let _accu = accu;
  let _l_accu = (
    /* [] */
    0
  );
  let _param = l;
  while (true) {
    const param = _param;
    const l_accu = _l_accu;
    const accu$1 = _accu;
    if (!param) {
      return [
        accu$1,
        rev_append(
          l_accu,
          /* [] */
          0
        )
      ];
    }
    const match = _2(f, accu$1, param.hd);
    _param = param.tl;
    _l_accu = {
      hd: match[1],
      tl: l_accu
    };
    _accu = match[0];
    continue;
  }
  ;
}
function partition(p, l) {
  let _yes = (
    /* [] */
    0
  );
  let _no = (
    /* [] */
    0
  );
  let _param = l;
  while (true) {
    const param = _param;
    const no = _no;
    const yes = _yes;
    if (!param) {
      return [
        rev_append(
          yes,
          /* [] */
          0
        ),
        rev_append(
          no,
          /* [] */
          0
        )
      ];
    }
    const l$1 = param.tl;
    const x = param.hd;
    if (_1(p, x)) {
      _param = l$1;
      _yes = {
        hd: x,
        tl: yes
      };
      continue;
    }
    _param = l$1;
    _no = {
      hd: x,
      tl: no
    };
    continue;
  }
  ;
}
function partition_map(p, l) {
  let _left = (
    /* [] */
    0
  );
  let _right = (
    /* [] */
    0
  );
  let _param = l;
  while (true) {
    const param = _param;
    const right = _right;
    const left = _left;
    if (!param) {
      return [
        rev_append(
          left,
          /* [] */
          0
        ),
        rev_append(
          right,
          /* [] */
          0
        )
      ];
    }
    const l$1 = param.tl;
    const v = _1(p, param.hd);
    if (v.TAG === /* Left */
    0) {
      _param = l$1;
      _left = {
        hd: v._0,
        tl: left
      };
      continue;
    }
    _param = l$1;
    _right = {
      hd: v._0,
      tl: right
    };
    continue;
  }
  ;
}
function split(param) {
  if (!param) {
    return [
      /* [] */
      0,
      /* [] */
      0
    ];
  }
  const match = param.hd;
  const match$1 = split(param.tl);
  return [
    {
      hd: match[0],
      tl: match$1[0]
    },
    {
      hd: match[1],
      tl: match$1[1]
    }
  ];
}
function combine(l1, l2) {
  if (l1) {
    if (l2) {
      return {
        hd: [
          l1.hd,
          l2.hd
        ],
        tl: combine(l1.tl, l2.tl)
      };
    }
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "List.combine"
    });
  }
  if (!l2) {
    return (
      /* [] */
      0
    );
  }
  throw new MelangeError("Invalid_argument", {
    MEL_EXN_ID: "Invalid_argument",
    _1: "List.combine"
  });
}
function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  const h2 = l2.hd;
  const h1 = l1.hd;
  if (_2(cmp, h1, h2) <= 0) {
    return {
      hd: h1,
      tl: merge(cmp, l1.tl, l2)
    };
  } else {
    return {
      hd: h2,
      tl: merge(cmp, l1, l2.tl)
    };
  }
}
function stable_sort(cmp, l) {
  const rev_merge = function(_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const h2 = l2.hd;
      const h1 = l1.hd;
      if (_2(cmp, h1, h2) <= 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue;
    }
    ;
  };
  const rev_merge_rev = function(_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const h2 = l2.hd;
      const h1 = l1.hd;
      if (_2(cmp, h1, h2) > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = l1.tl;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = l2.tl;
      continue;
    }
    ;
  };
  const sort2 = function(n, l2) {
    if (n !== 2) {
      if (n === 3 && l2) {
        const match = l2.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l2.hd;
            const s = _2(cmp, x1, x2) <= 0 ? _2(cmp, x2, x3) <= 0 ? {
              hd: x1,
              tl: {
                hd: x2,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x1, x3) <= 0 ? {
              hd: x1,
              tl: {
                hd: x3,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : {
              hd: x3,
              tl: {
                hd: x1,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x1, x3) <= 0 ? {
              hd: x2,
              tl: {
                hd: x1,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x2, x3) <= 0 ? {
              hd: x2,
              tl: {
                hd: x3,
                tl: {
                  hd: x1,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : {
              hd: x3,
              tl: {
                hd: x2,
                tl: {
                  hd: x1,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            };
            return [
              s,
              match$1.tl
            ];
          }
        }
      }
    } else if (l2) {
      const match$2 = l2.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l2.hd;
        const s$1 = _2(cmp, x1$1, x2$1) <= 0 ? {
          hd: x1$1,
          tl: {
            hd: x2$1,
            tl: (
              /* [] */
              0
            )
          }
        } : {
          hd: x2$1,
          tl: {
            hd: x1$1,
            tl: (
              /* [] */
              0
            )
          }
        };
        return [
          s$1,
          match$2.tl
        ];
      }
    }
    const n1 = n >> 1;
    const n2 = n - n1 | 0;
    const match$3 = rev_sort(n1, l2);
    const match$4 = rev_sort(n2, match$3[1]);
    return [
      rev_merge_rev(
        match$3[0],
        match$4[0],
        /* [] */
        0
      ),
      match$4[1]
    ];
  };
  const rev_sort = function(n, l2) {
    if (n !== 2) {
      if (n === 3 && l2) {
        const match = l2.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l2.hd;
            const s = _2(cmp, x1, x2) > 0 ? _2(cmp, x2, x3) > 0 ? {
              hd: x1,
              tl: {
                hd: x2,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x1, x3) > 0 ? {
              hd: x1,
              tl: {
                hd: x3,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : {
              hd: x3,
              tl: {
                hd: x1,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x1, x3) > 0 ? {
              hd: x2,
              tl: {
                hd: x1,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : _2(cmp, x2, x3) > 0 ? {
              hd: x2,
              tl: {
                hd: x3,
                tl: {
                  hd: x1,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            } : {
              hd: x3,
              tl: {
                hd: x2,
                tl: {
                  hd: x1,
                  tl: (
                    /* [] */
                    0
                  )
                }
              }
            };
            return [
              s,
              match$1.tl
            ];
          }
        }
      }
    } else if (l2) {
      const match$2 = l2.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l2.hd;
        const s$1 = _2(cmp, x1$1, x2$1) > 0 ? {
          hd: x1$1,
          tl: {
            hd: x2$1,
            tl: (
              /* [] */
              0
            )
          }
        } : {
          hd: x2$1,
          tl: {
            hd: x1$1,
            tl: (
              /* [] */
              0
            )
          }
        };
        return [
          s$1,
          match$2.tl
        ];
      }
    }
    const n1 = n >> 1;
    const n2 = n - n1 | 0;
    const match$3 = sort2(n1, l2);
    const match$4 = sort2(n2, match$3[1]);
    return [
      rev_merge(
        match$3[0],
        match$4[0],
        /* [] */
        0
      ),
      match$4[1]
    ];
  };
  const len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort2(len, l)[0];
  }
}
function sort_uniq(cmp, l) {
  const rev_merge = function(_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const t2 = l2.tl;
      const h2 = l2.hd;
      const t1 = l1.tl;
      const h1 = l1.hd;
      const c = _2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue;
      }
      if (c < 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue;
    }
    ;
  };
  const rev_merge_rev = function(_l1, _l2, _accu) {
    while (true) {
      const accu = _accu;
      const l2 = _l2;
      const l1 = _l1;
      if (!l1) {
        return rev_append(l2, accu);
      }
      if (!l2) {
        return rev_append(l1, accu);
      }
      const t2 = l2.tl;
      const h2 = l2.hd;
      const t1 = l1.tl;
      const h1 = l1.hd;
      const c = _2(cmp, h1, h2);
      if (c === 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l2 = t2;
        _l1 = t1;
        continue;
      }
      if (c > 0) {
        _accu = {
          hd: h1,
          tl: accu
        };
        _l1 = t1;
        continue;
      }
      _accu = {
        hd: h2,
        tl: accu
      };
      _l2 = t2;
      continue;
    }
    ;
  };
  const sort2 = function(n, l2) {
    if (n !== 2) {
      if (n === 3 && l2) {
        const match = l2.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l2.hd;
            const c = _2(cmp, x1, x2);
            let s;
            if (c === 0) {
              const c$1 = _2(cmp, x2, x3);
              s = c$1 === 0 ? {
                hd: x2,
                tl: (
                  /* [] */
                  0
                )
              } : c$1 < 0 ? {
                hd: x2,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              } : {
                hd: x3,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              };
            } else if (c < 0) {
              const c$2 = _2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                };
              } else if (c$2 < 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              } else {
                const c$3 = _2(cmp, x1, x3);
                s = c$3 === 0 ? {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                } : c$3 < 0 ? {
                  hd: x1,
                  tl: {
                    hd: x3,
                    tl: {
                      hd: x2,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                } : {
                  hd: x3,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              }
            } else {
              const c$4 = _2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                };
              } else if (c$4 < 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              } else {
                const c$5 = _2(cmp, x2, x3);
                s = c$5 === 0 ? {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                } : c$5 < 0 ? {
                  hd: x2,
                  tl: {
                    hd: x3,
                    tl: {
                      hd: x1,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                } : {
                  hd: x3,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              }
            }
            return [
              s,
              match$1.tl
            ];
          }
        }
      }
    } else if (l2) {
      const match$2 = l2.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l2.hd;
        const c$6 = _2(cmp, x1$1, x2$1);
        const s$1 = c$6 === 0 ? {
          hd: x1$1,
          tl: (
            /* [] */
            0
          )
        } : c$6 < 0 ? {
          hd: x1$1,
          tl: {
            hd: x2$1,
            tl: (
              /* [] */
              0
            )
          }
        } : {
          hd: x2$1,
          tl: {
            hd: x1$1,
            tl: (
              /* [] */
              0
            )
          }
        };
        return [
          s$1,
          match$2.tl
        ];
      }
    }
    const n1 = n >> 1;
    const n2 = n - n1 | 0;
    const match$3 = rev_sort(n1, l2);
    const match$4 = rev_sort(n2, match$3[1]);
    return [
      rev_merge_rev(
        match$3[0],
        match$4[0],
        /* [] */
        0
      ),
      match$4[1]
    ];
  };
  const rev_sort = function(n, l2) {
    if (n !== 2) {
      if (n === 3 && l2) {
        const match = l2.tl;
        if (match) {
          const match$1 = match.tl;
          if (match$1) {
            const x3 = match$1.hd;
            const x2 = match.hd;
            const x1 = l2.hd;
            const c = _2(cmp, x1, x2);
            let s;
            if (c === 0) {
              const c$1 = _2(cmp, x2, x3);
              s = c$1 === 0 ? {
                hd: x2,
                tl: (
                  /* [] */
                  0
                )
              } : c$1 > 0 ? {
                hd: x2,
                tl: {
                  hd: x3,
                  tl: (
                    /* [] */
                    0
                  )
                }
              } : {
                hd: x3,
                tl: {
                  hd: x2,
                  tl: (
                    /* [] */
                    0
                  )
                }
              };
            } else if (c > 0) {
              const c$2 = _2(cmp, x2, x3);
              if (c$2 === 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                };
              } else if (c$2 > 0) {
                s = {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x3,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              } else {
                const c$3 = _2(cmp, x1, x3);
                s = c$3 === 0 ? {
                  hd: x1,
                  tl: {
                    hd: x2,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                } : c$3 > 0 ? {
                  hd: x1,
                  tl: {
                    hd: x3,
                    tl: {
                      hd: x2,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                } : {
                  hd: x3,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x2,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              }
            } else {
              const c$4 = _2(cmp, x1, x3);
              if (c$4 === 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                };
              } else if (c$4 > 0) {
                s = {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: {
                      hd: x3,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              } else {
                const c$5 = _2(cmp, x2, x3);
                s = c$5 === 0 ? {
                  hd: x2,
                  tl: {
                    hd: x1,
                    tl: (
                      /* [] */
                      0
                    )
                  }
                } : c$5 > 0 ? {
                  hd: x2,
                  tl: {
                    hd: x3,
                    tl: {
                      hd: x1,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                } : {
                  hd: x3,
                  tl: {
                    hd: x2,
                    tl: {
                      hd: x1,
                      tl: (
                        /* [] */
                        0
                      )
                    }
                  }
                };
              }
            }
            return [
              s,
              match$1.tl
            ];
          }
        }
      }
    } else if (l2) {
      const match$2 = l2.tl;
      if (match$2) {
        const x2$1 = match$2.hd;
        const x1$1 = l2.hd;
        const c$6 = _2(cmp, x1$1, x2$1);
        const s$1 = c$6 === 0 ? {
          hd: x1$1,
          tl: (
            /* [] */
            0
          )
        } : c$6 > 0 ? {
          hd: x1$1,
          tl: {
            hd: x2$1,
            tl: (
              /* [] */
              0
            )
          }
        } : {
          hd: x2$1,
          tl: {
            hd: x1$1,
            tl: (
              /* [] */
              0
            )
          }
        };
        return [
          s$1,
          match$2.tl
        ];
      }
    }
    const n1 = n >> 1;
    const n2 = n - n1 | 0;
    const match$3 = sort2(n1, l2);
    const match$4 = sort2(n2, match$3[1]);
    return [
      rev_merge(
        match$3[0],
        match$4[0],
        /* [] */
        0
      ),
      match$4[1]
    ];
  };
  const len = length(l);
  if (len < 2) {
    return l;
  } else {
    return sort2(len, l)[0];
  }
}
function compare_lengths(_l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  }
  ;
}
function compare_length_with(_l, _n) {
  while (true) {
    const n = _n;
    const l = _l;
    if (!l) {
      if (n === 0) {
        return 0;
      } else if (n > 0) {
        return -1;
      } else {
        return 1;
      }
    }
    if (n <= 0) {
      return 1;
    }
    _n = n - 1 | 0;
    _l = l.tl;
    continue;
  }
  ;
}
function is_empty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}
function equal(eq, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return false;
      } else {
        return true;
      }
    }
    if (!l2) {
      return false;
    }
    if (!_2(eq, l1.hd, l2.hd)) {
      return false;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  }
  ;
}
function compare(cmp, _l1, _l2) {
  while (true) {
    const l2 = _l2;
    const l1 = _l1;
    if (!l1) {
      if (l2) {
        return -1;
      } else {
        return 0;
      }
    }
    if (!l2) {
      return 1;
    }
    const c = _2(cmp, l1.hd, l2.hd);
    if (c !== 0) {
      return c;
    }
    _l2 = l2.tl;
    _l1 = l1.tl;
    continue;
  }
  ;
}
function to_seq(l) {
  const aux = function(l2, param) {
    if (!l2) {
      return (
        /* Nil */
        0
      );
    }
    const tail = l2.tl;
    return {
      TAG: (
        /* Cons */
        0
      ),
      _0: l2.hd,
      _1: function(param2) {
        return aux(tail, param2);
      }
    };
  };
  return function(param) {
    return aux(l, param);
  };
}
function of_seq_dps(_dst, _offset, _seq) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const seq = _seq;
    const match = _1(seq, void 0);
    if (
      /* tag */
      typeof match === "number" || typeof match === "string"
    ) {
      dst[offset] = /* [] */
      0;
      return;
    }
    const x1 = match._0;
    const match$1 = _1(match._1, void 0);
    if (
      /* tag */
      typeof match$1 === "number" || typeof match$1 === "string"
    ) {
      dst[offset] = {
        hd: x1,
        tl: (
          /* [] */
          0
        )
      };
      return;
    }
    const block = {
      hd: match$1._0,
      tl: 24029
    };
    dst[offset] = {
      hd: x1,
      tl: block
    };
    _seq = match$1._1;
    _offset = "tl";
    _dst = block;
    continue;
  }
  ;
}
function of_seq(seq) {
  const match = _1(seq, void 0);
  if (
    /* tag */
    typeof match === "number" || typeof match === "string"
  ) {
    return (
      /* [] */
      0
    );
  }
  const x1 = match._0;
  const match$1 = _1(match._1, void 0);
  if (
    /* tag */
    typeof match$1 === "number" || typeof match$1 === "string"
  ) {
    return {
      hd: x1,
      tl: (
        /* [] */
        0
      )
    };
  }
  const block = {
    hd: match$1._0,
    tl: 24029
  };
  return {
    hd: x1,
    tl: (of_seq_dps(block, "tl", match$1._1), block)
  };
}
var append = $at;
var concat = flatten;
var filter = find_all;
var sort = stable_sort;
var fast_sort = stable_sort;
export {
  append,
  assoc,
  assoc_opt,
  assq,
  assq_opt,
  combine,
  compare,
  compare_length_with,
  compare_lengths,
  concat,
  concat_map,
  cons,
  drop,
  drop_while,
  equal,
  exists,
  exists2,
  fast_sort,
  filter,
  filter_map,
  filteri,
  find,
  find_all,
  find_index,
  find_map,
  find_mapi,
  find_opt,
  flatten,
  fold_left,
  fold_left2,
  fold_left_map,
  fold_right,
  fold_right2,
  for_all,
  for_all2,
  hd,
  init,
  is_empty,
  iter,
  iter2,
  iteri,
  length,
  map,
  map2,
  mapi,
  mem,
  mem_assoc,
  mem_assq,
  memq,
  merge,
  nth,
  nth_opt,
  of_seq,
  partition,
  partition_map,
  remove_assoc,
  remove_assq,
  rev,
  rev_append,
  rev_map,
  rev_map2,
  sort,
  sort_uniq,
  split,
  stable_sort,
  take,
  take_while,
  tl,
  to_seq
};
//# sourceMappingURL=melange_list__js.js.map
