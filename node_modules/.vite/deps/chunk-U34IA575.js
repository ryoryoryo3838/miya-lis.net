import {
  MelangeError,
  create
} from "./chunk-3PFLCYLG.js";

// _build/default/src/output/node_modules/melange.js/caml.js
function caml_string_compare(s1, s2) {
  if (s1 === s2) {
    return 0;
  } else if (s1 < s2) {
    return -1;
  } else {
    return 1;
  }
}

// _build/default/src/output/node_modules/melange.js/caml_int64.js
function lsl_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  const lo = x[1];
  if (numBits >= 32) {
    return [
      lo << (numBits - 32 | 0),
      0
    ];
  } else {
    return [
      lo >>> (32 - numBits | 0) | x[0] << numBits,
      lo << numBits >>> 0
    ];
  }
}
function lsr_(x, numBits) {
  if (numBits === 0) {
    return x;
  }
  const hi = x[0];
  const offset = numBits - 32 | 0;
  if (offset === 0) {
    return [
      0,
      hi >>> 0
    ];
  } else if (offset > 0) {
    return [
      0,
      hi >>> offset
    ];
  } else {
    return [
      hi >>> numBits,
      (hi << (-offset | 0) | x[1] >>> numBits) >>> 0
    ];
  }
}
function or_(param, param$1) {
  return [
    param[0] | param$1[0],
    (param[1] | param$1[1]) >>> 0
  ];
}
function and_(param, param$1) {
  return [
    param[0] & param$1[0],
    (param[1] & param$1[1]) >>> 0
  ];
}
function of_int32(lo) {
  return [
    lo < 0 ? -1 : 0,
    lo >>> 0
  ];
}

// _build/default/src/output/node_modules/melange.js/caml_bytes.js
function set(s, i, ch) {
  if (i < 0 || i >= s.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  s[i] = ch;
}
function get(s, i) {
  if (i < 0 || i >= s.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  return s[i];
}
function caml_fill_bytes(s, i, l, c) {
  if (l <= 0) {
    return;
  }
  for (let k = i, k_finish = l + i | 0; k < k_finish; ++k) {
    s[k] = c;
  }
}
function caml_create_bytes(len) {
  if (len < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "String.create"
    });
  }
  const result = new Array(len);
  for (let i = 0; i < len; ++i) {
    result[i] = /* '\000' */
    0;
  }
  return result;
}
function caml_blit_bytes(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  if (s1 === s2) {
    if (i1 < i2) {
      const range_a = (s1.length - i2 | 0) - 1 | 0;
      const range_b = len - 1 | 0;
      const range = range_a > range_b ? range_b : range_a;
      for (let j = range; j >= 0; --j) {
        s1[i2 + j | 0] = s1[i1 + j | 0];
      }
      return;
    }
    if (i1 <= i2) {
      return;
    }
    const range_a$1 = (s1.length - i1 | 0) - 1 | 0;
    const range_b$1 = len - 1 | 0;
    const range$1 = range_a$1 > range_b$1 ? range_b$1 : range_a$1;
    for (let k = 0; k <= range$1; ++k) {
      s1[i2 + k | 0] = s1[i1 + k | 0];
    }
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1[i1 + i | 0];
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1[i1 + i$1 | 0];
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\000' */
    0;
  }
}
function bytes_to_string(a) {
  let i = 0;
  let len = a.length;
  let s = "";
  let s_len = len;
  if (i === 0 && len <= 4096 && len === a.length) {
    return String.fromCharCode.apply(null, a);
  }
  let offset = 0;
  while (s_len > 0) {
    const next = s_len < 1024 ? s_len : 1024;
    const tmp_bytes = new Array(next);
    for (let k = 0; k < next; ++k) {
      tmp_bytes[k] = a[k + offset | 0];
    }
    s = s + String.fromCharCode.apply(null, tmp_bytes);
    s_len = s_len - next | 0;
    offset = offset + next | 0;
  }
  ;
  return s;
}
function caml_blit_string(s1, i1, s2, i2, len) {
  if (len <= 0) {
    return;
  }
  const off1 = s1.length - i1 | 0;
  if (len <= off1) {
    for (let i = 0; i < len; ++i) {
      s2[i2 + i | 0] = s1.charCodeAt(i1 + i | 0);
    }
    return;
  }
  for (let i$1 = 0; i$1 < off1; ++i$1) {
    s2[i2 + i$1 | 0] = s1.charCodeAt(i1 + i$1 | 0);
  }
  for (let i$2 = off1; i$2 < len; ++i$2) {
    s2[i2 + i$2 | 0] = /* '\000' */
    0;
  }
}
function bytes_of_string(s) {
  const len = s.length;
  const res = new Array(len);
  for (let i = 0; i < len; ++i) {
    res[i] = s.charCodeAt(i);
  }
  return res;
}
function bswap16(x) {
  return (x & 255) << 8 | (x & 65280) >>> 8;
}
function bswap32(x) {
  return (x & 255) << 24 | (x & 65280) << 8 | (x & 16711680) >>> 8 | (x & -16777216) >>> 24;
}
function bswap64(x) {
  return or_(or_(or_(or_(or_(or_(or_(lsl_(and_(x, [
    0,
    255
  ]), 56), lsl_(and_(x, [
    0,
    65280
  ]), 40)), lsl_(and_(x, [
    0,
    16711680
  ]), 24)), lsl_(and_(x, [
    0,
    4278190080
  ]), 8)), lsr_(and_(x, [
    255,
    0
  ]), 8)), lsr_(and_(x, [
    65280,
    0
  ]), 24)), lsr_(and_(x, [
    16711680,
    0
  ]), 40)), lsr_(and_(x, [
    -16777216,
    0
  ]), 56));
}
function get16u(str, idx) {
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  return b2 << 8 | b1;
}
function get16(str, idx) {
  if (idx < 0 || (idx + 1 | 0) >= str.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  return get16u(str, idx);
}
function get32(str, idx) {
  if (idx < 0 || (idx + 3 | 0) >= str.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  return b4 << 24 | b3 << 16 | b2 << 8 | b1;
}
function get64(str, idx) {
  if (idx < 0 || (idx + 7 | 0) >= str.length) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  const b1 = str[idx];
  const b2 = str[idx + 1 | 0];
  const b3 = str[idx + 2 | 0];
  const b4 = str[idx + 3 | 0];
  const b5 = str[idx + 4 | 0];
  const b6 = str[idx + 5 | 0];
  const b7 = str[idx + 6 | 0];
  const b8 = str[idx + 7 | 0];
  return or_(lsl_(or_(lsl_(or_(lsl_(or_(lsl_(or_(lsl_(or_(lsl_(or_(lsl_(of_int32(b8), 56), of_int32(b7)), 48), of_int32(b6)), 40), of_int32(b5)), 32), of_int32(b4)), 24), of_int32(b3)), 16), of_int32(b2)), 8), of_int32(b1));
}

// _build/default/src/output/node_modules/melange.js/caml_external_polyfill.js
var getGlobalThis = function() {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  if (typeof this !== "undefined") return this;
  throw new Error("Unable to locate global `this`");
};
var resolve = function(s) {
  var myGlobal = getGlobalThis();
  if (myGlobal[s] === void 0) {
    throw new Error(s + " not polyfilled by Melange yet\n");
  }
  return myGlobal[s];
};

// _build/default/src/output/node_modules/melange.js/caml_string.js
function get2(s, i) {
  if (i >= s.length || i < 0) {
    throw new MelangeError("Invalid_argument", {
      MEL_EXN_ID: "Invalid_argument",
      _1: "index out of bounds"
    });
  }
  return s.charCodeAt(i);
}

// _build/default/src/output/node_modules/melange.js/caml_sys.js
var os_type = function(_) {
  if (typeof process !== "undefined" && process.platform === "win32") {
    return "Win32";
  } else {
    return "Unix";
  }
};
function caml_sys_executable_name(param) {
  if (typeof process === "undefined") {
    return "";
  }
  const argv = process.argv;
  if (argv == null) {
    return "";
  } else {
    return argv[0];
  }
}

// _build/default/src/output/node_modules/melange/stdlib.js
var Exit = create("Stdlib.Exit");
function $at_dps(_dst, _offset, _l1, l2) {
  while (true) {
    const dst = _dst;
    const offset = _offset;
    const l1 = _l1;
    if (!l1) {
      dst[offset] = l2;
      return;
    }
    const match = l1.tl;
    const h1 = l1.hd;
    if (!match) {
      dst[offset] = {
        hd: h1,
        tl: l2
      };
      return;
    }
    const match$1 = match.tl;
    const h2 = match.hd;
    if (!match$1) {
      dst[offset] = {
        hd: h1,
        tl: {
          hd: h2,
          tl: l2
        }
      };
      return;
    }
    const block = {
      hd: match$1.hd,
      tl: 24029
    };
    dst[offset] = {
      hd: h1,
      tl: {
        hd: h2,
        tl: block
      }
    };
    _l1 = match$1.tl;
    _offset = "tl";
    _dst = block;
    continue;
  }
  ;
}
function $at(l1, l2) {
  if (!l1) {
    return l2;
  }
  const match = l1.tl;
  const h1 = l1.hd;
  if (!match) {
    return {
      hd: h1,
      tl: l2
    };
  }
  const match$1 = match.tl;
  const h2 = match.hd;
  if (!match$1) {
    return {
      hd: h1,
      tl: {
        hd: h2,
        tl: l2
      }
    };
  }
  const block = {
    hd: match$1.hd,
    tl: 24029
  };
  return {
    hd: h1,
    tl: {
      hd: h2,
      tl: ($at_dps(block, "tl", match$1.tl, l2), block)
    }
  };
}
var Not_found = "Not_found";

export {
  caml_string_compare,
  set,
  get,
  caml_fill_bytes,
  caml_create_bytes,
  caml_blit_bytes,
  bytes_to_string,
  caml_blit_string,
  bytes_of_string,
  bswap16,
  bswap32,
  bswap64,
  get16u,
  get16,
  get32,
  get64,
  resolve,
  get2,
  os_type,
  caml_sys_executable_name,
  $at,
  Not_found
};
//# sourceMappingURL=chunk-U34IA575.js.map
